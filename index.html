<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© (V10 - Ø§Ù„Ø·ÙˆØ§Ø¨ÙŠØ± Ø§Ù„ØµØ§Ø±Ù…Ø©)</title>
    <style>
        :root { --primary: #2563eb; --success: #10b981; --danger: #ef4444; --warning: #f59e0b; --bg: #f8fafc; --border: #cbd5e1; }
        * { box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: var(--bg); font-size: 13.5px; direction: rtl; }
        .app-container { max-width: 1400px; margin: 0 auto; padding: 10px; }
        .toolbar { display: flex; flex-wrap: wrap; gap: 10px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 20px; align-items: center; }
        h1 { margin: 0; font-size: 1.3rem; margin-left: auto; color: #1e293b; font-weight: 800; }
        button { cursor: pointer; padding: 8px 16px; border: 1px solid var(--border); background: white; border-radius: 6px; font-weight: 600; transition: all 0.2s; font-family: inherit; }
        button:hover { transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        button.primary { background: var(--primary); color: white; border-color: var(--primary); }
        button.success { background: var(--success); color: white; border-color: var(--success); }
        button.danger { background: var(--danger); color: white; border-color: var(--danger); }
        input, select { padding: 8px; border: 1px solid var(--border); border-radius: 5px; font-family: inherit; }
        .tabs { display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 2px solid #e2e8f0; background: white; border-radius: 8px 8px 0 0; padding: 0 10px; }
        .tab { padding: 12px 24px; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; color: #64748b; font-weight: 600; }
        .tab:hover { background: #f8fafc; color: var(--primary); }
        .tab.active { border-bottom-color: var(--primary); color: var(--primary); }
        .view { display: none; }
        .view.active { display: block; }
        .grid-container { overflow-x: auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); border: 1px solid var(--border); }
        .schedule-table { border-collapse: collapse; width: 100%; min-width: 1000px; }
        .schedule-table th, .schedule-table td { border: 1px solid #e2e8f0; text-align: center; padding: 4px; height: 38px; font-size: 0.85rem; }
        .schedule-table th { background: #f8fafc; position: sticky; top: 0; z-index: 10; font-weight: 700; color: #334155; }
        .schedule-table th.emp-col { position: sticky; right: 0; z-index: 20; width: 170px; text-align: right; padding-right: 12px; border-left: 2px solid #cbd5e1; background: #f8fafc; }
        .schedule-table td.emp-col { position: sticky; right: 0; z-index: 5; background: white; text-align: right; padding-right: 12px; font-weight: 600; border-left: 2px solid #cbd5e1; color: #1e293b; }
        .cell { cursor: pointer; user-select: none; transition: background 0.15s; font-weight: 600; }
        .cell:hover { filter: brightness(0.95); }
        .cell.shift-M { background-color: #dbeafe; color: #1e40af; }
        .cell.shift-A { background-color: #fef3c7; color: #92400e; }
        .cell.shift-N { background-color: #1e293b; color: #f8fafc; }
        .cell.shift-OFF { background-color: #f0fdf4; color: #166534; }
        .cell.shift-VAC { background-color: #f3e8ff; color: #7e22ce; }
        .cell.shift-X { background-color: #fee2e2; color: #991b1b; }
        .violation { border: 3px solid var(--danger) !important; position: relative; }
        .emp-card { border: 1px solid var(--border); background: white; padding: 16px; border-radius: 10px; margin-bottom: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .emp-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px; border-bottom: 1px solid #f1f5f9; margin-bottom: 12px; }
        .pattern-editor { background: #f8fafc; padding: 12px; border-radius: 8px; border: 1px dashed var(--border); margin-top: 10px; }
        .flex-counts { display: flex; gap: 10px; flex-wrap: wrap; }
        .flex-counts div { display: flex; flex-direction: column; align-items: center; }
        .flex-counts label { font-size: 0.7rem; font-weight: 700; color: #64748b; }
        .flex-counts input { width: 45px; text-align: center; font-weight: 600; border: 1px solid #cbd5e1; border-radius: 4px; padding: 4px; }
        .depot-quotas { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-top: 10px; }
        .depot-quotas div { background: #fff7ed; padding: 6px; border: 1px solid #ffedd5; border-radius: 6px; }
        .depot-quotas label { font-size: 0.7rem; font-weight: 700; color: #9a3412; display: block; }
        .depot-quotas input { width: 100%; text-align: center; font-weight: 600; margin-top: 2px; }
        .vacation-input { background: #f3e8ff; padding: 8px; border-radius: 6px; border: 1px solid #e9d5ff; margin-top: 10px; }
        .vacation-input input { width: 100%; padding: 5px; border: 1px solid #d8b4fe; border-radius: 4px; }
        #loader { position: fixed; inset: 0; background: rgba(255,255,255,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; }
        .report-box { margin-top: 20px; padding: 16px; background: white; border: 1px solid var(--border); border-radius: 10px; }
        .report-item { margin-bottom: 4px; padding: 6px 10px; background: #fff1f2; color: #9f1239; border-radius: 4px; border-right: 3px solid var(--danger); font-size: 0.9rem; font-weight: 500; }
        .report-ok { background: #d1fae5; color: #065f46; padding: 15px; text-align: center; font-weight: 700; border-radius: 8px; }
        .alert-box { background: #dbeafe; border: 1px solid #93c5fd; padding: 12px; border-radius: 8px; margin: 10px 0; color: #1e40af; font-weight: 600; font-size: 0.9rem; text-align: center; }
        .req-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .req-table th, .req-table td { border: 1px solid #e2e8f0; padding: 8px; text-align: center; }
        .req-input { width: 50px; text-align: center; font-weight: 600; }
        .badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; font-weight: 700; margin-right: 5px; }
        .badge.success { background: #d1fae5; color: #065f46; }
    </style>
</head>
<body>

<div id="loader">
    <div style="font-size: 2.5rem;">ğŸ—ï¸</div>
    <div style="margin-top: 10px; font-weight: 700; color: #334155;">Ø¬Ø§Ø±ÙŠ ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø§Ù… Ø§Ù„Ø·ÙˆØ§Ø¨ÙŠØ±...</div>
</div>

<div class="app-container">
    <div class="toolbar">
        <h1>ğŸ—“ï¸ Ù†Ø¸Ø§Ù… Ø§Ù„Ø³ÙŠØ¯Ø© Ø²ÙŠÙ†Ø¨ (V10 - Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª Ø§Ù„ØµØ§Ø±Ù…Ø©)</h1>
        <select id="selYear"></select>
        <select id="selMonth"></select>
        <button onclick="loadData()">ğŸ”„ ØªØ­Ø¯ÙŠØ«</button>
        <button class="primary" onclick="saveData()">ğŸ’¾ Ø­ÙØ¸</button>
        <div style="flex-grow:1; text-align:left; font-size:0.8rem; color:#64748b;">
             <span id="lastUpdated"></span>
        </div>
    </div>

    <div class="tabs">
        <div class="tab active" onclick="switchTab('schedule')">Ø§Ù„Ø¬Ø¯ÙˆÙ„</div>
        <div class="tab" onclick="switchTab('employees')">Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ†</div>
        <div class="tab" onclick="switchTab('settings')">Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</div>
    </div>

    <div id="view-schedule" class="view active">
        <div class="alert-box">
            ğŸš§ <strong>Ù†Ø¸Ø§Ù… Ø§Ù„Ø·ÙˆØ§Ø¨ÙŠØ±:</strong> Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù…Ø·Ù„Ù‚Ø© Ù„Ù„Ø´ÙØª Ø§Ù„Ø¯ÙˆØ§Ø± ÙÙŠ Ø§Ù„Ù†Ù‡Ø§Ø±. ØªØ´ØªÙŠØª Ø¥Ø¬Ø§Ø²Ø§Øª Ø¥Ø¬Ø¨Ø§Ø±ÙŠ.
        </div>
        <div class="toolbar" style="background:transparent; padding:0; box-shadow:none; justify-content:space-between;">
            <div>
                <button onclick="generateScheduleV10()" class="primary">âš¡ ØªÙˆØ²ÙŠØ¹ (Ù†Ø¸Ø§Ù… Ø§Ù„Ø·ÙˆØ§Ø¨ÙŠØ±)</button>
                <button onclick="fillDepots()" class="success">ğŸ­ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹</button>
            </div>
            <div>
                <button onclick="clearMonth()" class="danger">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
                <button onclick="exportCSV()">ğŸ“„ Excel</button>
            </div>
        </div>
        <div class="grid-container">
            <table class="schedule-table" id="scheduleGrid"></table>
        </div>
        <div id="coverageReport" class="report-box"></div>
    </div>

    <div id="view-employees" class="view">
        <button class="primary" onclick="addEmployee()" style="margin-bottom: 15px;">â• Ø¥Ø¶Ø§ÙØ© Ù…ÙˆØ¸Ù</button>
        <div id="employeeList"></div>
    </div>

    <div id="view-settings" class="view">
        <div class="emp-card">
            <h3>1ï¸âƒ£ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ (Depots)</h3>
            <input type="text" id="settingDepots" style="width: 100%;" onchange="updateDepots()">
        </div>
        <div class="emp-card">
            <h3>2ï¸âƒ£ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (M, A, N)</h3>
            <div id="requirementsContainer"></div>
        </div>
        <div class="emp-card">
            <h3>3ï¸âƒ£ ØªØ­ÙƒÙ…</h3>
            <button class="danger" onclick="saveData(true)">âš ï¸ ØªØµÙÙŠØ± Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
        </div>
    </div>
</div>

<script>
    // ==========================================
    // === CONFIGURATION ===
    // ==========================================
    const API_URL = "https://script.google.com/macros/s/AKfycbz_Ax4qk6l7tmebex2kP9e2KCz4twS960mH5D2JxF8RIa0h_OeiAC96uTNSMunQrvha/exec";

    // ==========================================
    // === STATE & CONSTANTS ===
    // ==========================================
    let state = {
        employees: [],
        schedule: {},
        meta: { requirements: {}, depots: [] }
    };
    let appConfig = {
        depots: ["Budaiya", "IsaTown"],
        year: new Date().getFullYear(),
        month: new Date().getMonth() + 1
    };

    const SHIFTS = ["M", "A", "N", "OFF", "VAC", "X"];
    const WEEKDAYS = ["Ø£Ø­Ø¯", "Ø§Ø«Ù†ÙŠÙ†", "Ø«Ù„Ø§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®Ù…ÙŠØ³", "Ø¬Ù…Ø¹Ø©", "Ø³Ø¨Øª"];
    const MAX_CONSECUTIVE = 6;

    // --- RULES ---
    function isShiftFlipViolation(prev, next) {
        // NOTE: Safety gate ignores OFF/X/VAC as "neutral" transitions
        if (!prev || ['OFF', 'X', 'VAC'].includes(prev)) return false;
        if (next === 'OFF' || next === 'X' || next === 'VAC') return false;
        if (prev === 'N') return (next === 'M' || next === 'A');
        if (prev === 'A') return (next === 'M');
        return false;
    }

    function isWorkShift(s) { return (s === 'M' || s === 'A' || s === 'N'); }

    // ===========================
    // INIT
    // ===========================
    window.onload = () => { initDateSelectors(); loadData(); };

    function initDateSelectors() {
        const ySel = document.getElementById('selYear');
        const mSel = document.getElementById('selMonth');
        const curr = new Date().getFullYear();
        for(let y=curr-1; y<=curr+2; y++) ySel.add(new Option(y, y));
        ySel.value = curr;
        ["ÙŠÙ†Ø§ÙŠØ±","ÙØ¨Ø±Ø§ÙŠØ±","Ù…Ø§Ø±Ø³","Ø£Ø¨Ø±ÙŠÙ„","Ù…Ø§ÙŠÙˆ","ÙŠÙˆÙ†ÙŠÙˆ","ÙŠÙˆÙ„ÙŠÙˆ","Ø£ØºØ³Ø·Ø³","Ø³Ø¨ØªÙ…Ø¨Ø±","Ø£ÙƒØªÙˆØ¨Ø±","Ù†ÙˆÙÙ…Ø¨Ø±","Ø¯ÙŠØ³Ù…Ø¨Ø±"].forEach((m, i) => mSel.add(new Option(m, i+1)));
        mSel.value = new Date().getMonth()+1;
        ySel.onchange = () => { appConfig.year = parseInt(ySel.value); renderSchedule(); };
        mSel.onchange = () => { appConfig.month = parseInt(mSel.value); renderSchedule(); };
    }

    function switchTab(t) {
        document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
        document.querySelectorAll('.view').forEach(x=>x.classList.remove('active'));
        event.target.classList.add('active');
        document.getElementById(`view-${t}`).classList.add('active');
    }

    // ===========================
    // API
    // ===========================
    async function loadData() {
        showLoader(true);
        try {
            const res = await fetch(`${API_URL}?action=load`);
            const json = await res.json();
            if(json.ok) {
                const data = json.data || {};
                state.employees = data.employees || [];
                state.schedule = data.schedule || {};
                state.meta = data.meta || { requirements: {}, depots: [] };
                if(state.meta.depots && state.meta.depots.length) appConfig.depots = state.meta.depots;
                document.getElementById('settingDepots').value = appConfig.depots.join(', ');

                state.employees.forEach(emp => {
                    if(!emp.id) emp.id = 'emp_' + Math.random().toString(36).substr(2, 9);
                    if(!emp.patternType) emp.patternType = 'weekly';
                    if(!emp.weeklyTemplate) emp.weeklyTemplate = Array(7).fill("M");
                    if(!emp.flexCounts) emp.flexCounts = { M: 1, A: 2, N: 2, OFF: 2 };
                    if(!emp.depotQuotas) emp.depotQuotas = {};
                    if(!emp.vacationDates) emp.vacationDates = "";
                });

                // back-compat requirement keys if any
                const reqs = state.meta.requirements || {};
                for(let d in reqs) {
                    if(reqs[d] && reqs[d].D !== undefined) {
                        reqs[d].M = reqs[d].D; reqs[d].A = reqs[d].EN; reqs[d].N = reqs[d].LN;
                        delete reqs[d].D; delete reqs[d].EN; delete reqs[d].LN;
                    }
                }

                renderEmployees();
                renderRequirementsTable();
                renderSchedule();

                if(state.meta.updatedAt) document.getElementById('lastUpdated').innerText = new Date(state.meta.updatedAt).toLocaleTimeString();
            }
        } catch(e) { console.error(e); alert("ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„."); }
        finally { showLoader(false); }
    }

    async function saveData(reset = false) {
        showLoader(true);
        if(reset && !confirm("âš ï¸ Ù…Ø³Ø­ Ø§Ù„ÙƒÙ„ØŸ")) { showLoader(false); return; }
        if(reset) state = { employees: [], schedule: {}, meta: { requirements: {}, depots: [] } };
        state.meta.depots = appConfig.depots;
        state.meta.updatedAt = new Date().toISOString();
        try {
            await fetch(API_URL, {
                method: "POST",
                body: JSON.stringify({ action: "save", payload: { employees: state.employees, schedule: state.schedule, meta: state.meta } })
            });
            if(reset) {
                renderEmployees(); renderRequirementsTable(); renderSchedule();
                document.getElementById('settingDepots').value = "Budaiya, IsaTown";
            }
            document.getElementById('lastUpdated').innerText = new Date().toLocaleTimeString();
        } catch(e) { alert("Ø®Ø·Ø£ Ø­ÙØ¸."); }
        finally { showLoader(false); }
    }

    // ===========================
    // UI: requirements
    // ===========================
    function renderRequirementsTable() {
        const container = document.getElementById('requirementsContainer');
        if(!container) return;
        if(!state.meta.requirements) state.meta.requirements = {};
        let html = `<table class="req-table"><thead><tr><th>Ø§Ù„Ù…ÙˆÙ‚Ø¹</th><th>M</th><th>A</th><th>N</th></tr></thead><tbody>`;
        appConfig.depots.forEach(depot => {
            const req = state.meta.requirements[depot] || { M:0, A:0, N:0 };
            html += `<tr><td style="font-weight:700;">${depot}</td>
                <td><input type="number" min="0" class="req-input" value="${req.M || 0}" onchange="updateReq('${depot}', 'M', this.value)"></td>
                <td><input type="number" min="0" class="req-input" value="${req.A || 0}" onchange="updateReq('${depot}', 'A', this.value)"></td>
                <td><input type="number" min="0" class="req-input" value="${req.N || 0}" onchange="updateReq('${depot}', 'N', this.value)"></td></tr>`;
        });
        container.innerHTML = html + `</tbody></table>`;
    }
    function updateReq(depot, shift, value) {
        if(!state.meta.requirements[depot]) state.meta.requirements[depot] = {};
        state.meta.requirements[depot][shift] = parseInt(value) || 0;
    }

    // ===========================
    // UI: employees
    // ===========================
    function renderEmployees() {
        const container = document.getElementById('employeeList');
        if(!container) return;
        container.innerHTML = "";
        state.employees.forEach(emp => {
            const div = document.createElement('div');
            div.className = "emp-card";

            let weekHtml = "<div style='display:grid; grid-template-columns:repeat(7,1fr); gap:6px;'>";
            WEEKDAYS.forEach((day, i) => {
                const opts = SHIFTS.filter(s => s !== 'VAC' && s !== 'X')
                    .map(s => `<option value="${s}" ${emp.weeklyTemplate[i] === s ? 'selected' : ''}>${s}</option>`).join('');
                weekHtml += `<div style="text-align:center;">
                    <label style="font-size:0.7rem; color:#64748b;">${day}</label>
                    <select onchange="updateWeeklyTemplate('${emp.id}', ${i}, this.value)" style="width:100%; font-size:0.85rem;">${opts}</select>
                </div>`;
            });
            weekHtml += "</div>";

            let quotasHtml = `<div class="depot-quotas">`;
            appConfig.depots.forEach(depot => {
                const val = (emp.depotQuotas && emp.depotQuotas[depot]) || 0;
                quotasHtml += `<div><label>${depot}</label><input type="number" min="0" value="${val}" onchange="updateDepotQuota('${emp.id}', '${depot}', this.value)"></div>`;
            });
            quotasHtml += `</div>`;

            let vacationHtml = `<div class="vacation-input"><label>ğŸ–ï¸ Ø£ÙŠØ§Ù… Ø§Ù„Ø¥Ø¬Ø§Ø²Ø§Øª (Ù…Ø«Ø§Ù„: 5, 6)</label><input type="text" value="${emp.vacationDates || ''}" onchange="updateVacationDates('${emp.id}', this.value)"></div>`;

            const flex = emp.flexCounts || { M: 1, A: 2, N: 2, OFF: 2 };
            let patternHtml = "";
            if(emp.patternType === 'rolling') {
                patternHtml = `<div class="pattern-editor"><div class="flex-counts">
                        <div><label>M</label><input type="number" value="${flex.M}" onchange="updateFlexCount('${emp.id}', 'M', this.value)"></div>
                        <div><label>A</label><input type="number" value="${flex.A}" onchange="updateFlexCount('${emp.id}', 'A', this.value)"></div>
                        <div><label>N</label><input type="number" value="${flex.N}" onchange="updateFlexCount('${emp.id}', 'N', this.value)"></div>
                        <div><label>OFF</label><input type="number" value="${flex.OFF}" onchange="updateFlexCount('${emp.id}', 'OFF', this.value)"></div>
                    </div></div>`;
            } else if(emp.patternType === 'joker') {
                patternHtml = `<div class="pattern-editor"><div style="color:#d97706; font-weight:700;">ğŸƒ Ø¬ÙˆÙƒØ±</div><p style="font-size:0.8rem;">ÙŠØºØ·ÙŠ Ø§Ù„Ù†Ù‚Øµ ÙÙŠ Ø§Ù„Ù„ÙŠÙ„. Ø¢Ø®Ø± Ø®ÙŠØ§Ø± Ù„Ù„Ù†Ù‡Ø§Ø±.</p></div>`;
            } else {
                patternHtml = `<div class="pattern-editor">${weekHtml}</div>`;
            }

            // FIXED: use emp.patternType (not e.patternType)
            div.innerHTML = `
                <div class="emp-header">
                    <input type="text" value="${emp.name}" onchange="updateEmployee('${emp.id}', 'name', this.value)" style="font-weight:700; flex:1; border:none;">
                    <select onchange="updateEmployee('${emp.id}', 'patternType', this.value)" style="margin:0 10px;">
                        <option value="weekly" ${emp.patternType === 'weekly' ? 'selected' : ''}>Ø«Ø§Ø¨Øª</option>
                        <option value="rolling" ${emp.patternType === 'rolling' ? 'selected' : ''}>Ø¯ÙˆØ§Ø±</option>
                        <option value="joker" ${emp.patternType === 'joker' ? 'selected' : ''}>Ø¬ÙˆÙƒØ±</option>
                    </select>
                    <button class="danger" onclick="deleteEmployee('${emp.id}')">ğŸ—‘ï¸</button>
                </div>
                ${vacationHtml}
                <div style="margin:10px 0;">
                    <strong style="font-size:0.85rem; color:#64748b;">ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹:</strong>
                    ${quotasHtml}
                </div>
                ${patternHtml}
            `;
            container.appendChild(div);
        });
    }

    // --- HELPERS (UI) ---
    function addEmployee() {
        state.employees.push({
            id: 'emp_'+Math.random().toString(36).substr(2,9),
            name: "Ø¬Ø¯ÙŠØ¯",
            patternType: "weekly",
            weeklyTemplate: Array(7).fill("M"),
            flexCounts: { M:1, A:2, N:2, OFF:2 },
            depotQuotas: {},
            vacationDates: ""
        });
        renderEmployees();
    }
    function updateEmployee(id, k, v) {
        const e = state.employees.find(x=>x.id===id);
        if(e){ e[k]=v; if(k==='patternType') renderEmployees(); }
    }
    function updateWeeklyTemplate(id, i, v) {
        const e = state.employees.find(x=>x.id===id);
        if(e) e.weeklyTemplate[i]=v;
    }
    function updateFlexCount(id, s, v) {
        const e = state.employees.find(x=>x.id===id);
        if(e){ if(!e.flexCounts) e.flexCounts={}; e.flexCounts[s]=parseInt(v)||0; }
    }
    function updateDepotQuota(id, d, v) {
        const e = state.employees.find(x=>x.id===id);
        if(e){ if(!e.depotQuotas) e.depotQuotas={}; e.depotQuotas[d]=parseInt(v)||0; }
    }
    function updateVacationDates(id, v) {
        const e = state.employees.find(x=>x.id===id);
        if(e) e.vacationDates=v;
    }
    function deleteEmployee(id) {
        if(confirm('Ø­Ø°ÙØŸ')) {
            state.employees=state.employees.filter(x=>x.id!==id);
            renderEmployees();
            renderSchedule();
            saveData();
        }
    }
    function updateDepots() {
        appConfig.depots = document.getElementById('settingDepots').value.split(',').map(s=>s.trim()).filter(s=>s);
        renderRequirementsTable();
        renderEmployees();
    }

    // Backward compat wrappers used in old HTML (keep UI untouched)
    function updEmpWeek(id, i, v) { updateWeeklyTemplate(id, i, v); }
    function updFlex(id, s, v) { updateFlexCount(id, s, v); }
    function updQuota(id, d, v) { updateDepotQuota(id, d, v); }
    function updReq(d, s, v) { updateReq(d, s, v); }

    // ==========================================
    // === SCHEDULER: WEEK TEMPLATE + REPEAT (V10.1) ===
    // ==========================================
    function generateScheduleV10() {
        if(!confirm("ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„ØªÙˆØ²ÙŠØ¹ (V10.1)ØŸ\n\n- Ù†ÙØ³ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©\n- ØªÙˆÙ„ÙŠØ¯ Ø£Ø³Ø¨ÙˆØ¹ Ø«Ù… Ù†Ø³Ø®Ù‡\n- Patch Ù„Ù„Ø¥Ø¬Ø§Ø²Ø§Øª + Ø§Ù„Ø¹Ø¬Ø² + Ø§Ù„Ø³Ù„Ø§Ù…Ø©")) return;
        showLoader(true);

        setTimeout(() => {
            try {
                const key = getMonthKey();
                const numDays = daysInMonth(appConfig.year, appConfig.month);
                if(!state.schedule[key]) state.schedule[key] = {};
                const sched = state.schedule[key];
                state.employees.forEach(e => { if(!sched[e.id]) sched[e.id] = {}; });

                // 0) Preserve VAC if already set, then apply VAC from employee list
                applyVacations(numDays, sched);

                // 1) Compute daily needs (total across depots)
                const dailyNeeds = calculateDailyNeeds(numDays);

                // 2) init trackers
                const streaks = {};
                const prevShift = {};
                state.employees.forEach(emp => { streaks[emp.id] = 0; prevShift[emp.id] = 'OFF'; });

                // 3) apply fixed employees (monthly, repeating weekly template)
                applyFixedEmployees(numDays, sched, dailyNeeds, streaks, prevShift);

                // 4) build week blocks (Sun->Sat). First block can be partial (day1 -> Sat)
                const blocks = buildWeekBlocks(numDays);

                // 5) generate templates:
                //    - partial template for first block length
                //    - full-week template length 7
                const templates = {};
                const rollingEmps = state.employees.filter(e => e.patternType === 'rolling');
                const jokerEmps   = state.employees.filter(e => e.patternType === 'joker');

                blocks.forEach(block => {
                    const len = block.days.length;
                    if(!templates[len]) {
                        templates[len] = createWeekTemplate(len, block.days, sched, dailyNeeds, rollingEmps, jokerEmps);
                    }
                });

                // 6) apply templates to each block (repeat) with patch pass
                blocks.forEach(block => {
                    const len = block.days.length;
                    const tpl = templates[len];
                    applyWeekTemplate(block.days, tpl, sched, dailyNeeds, rollingEmps, jokerEmps, streaks, prevShift);
                    patchDayDeficits(block.days, sched, dailyNeeds, rollingEmps, jokerEmps, streaks, prevShift);
                });

                // 7) Final safety + max6 enforcement scan
                enforceSafetyAndMax6(numDays, sched);

                renderSchedule();
                saveData();
                showLoader(false);
                alert("âœ… ØªÙ… Ø§Ù„ØªÙˆØ²ÙŠØ¹ (Ø£Ø³Ø¨ÙˆØ¹ + Ù†Ø³Ø®Ø© + Patch)!");
            } catch(e) {
                console.error(e);
                showLoader(false);
                alert("Ø®Ø·Ø£: " + e.message);
            }
        }, 80);
    }

    // ----------------------------
    // Week blocks helpers
    // ----------------------------
    function buildWeekBlocks(numDays) {
        // week: Sunday(0) -> Saturday(6)
        const blocks = [];
        let d = 1;
        while(d <= numDays) {
            const dow = new Date(appConfig.year, appConfig.month-1, d).getDay(); // 0..6
            const end = Math.min(d + (6 - dow), numDays);
            const days = [];
            for(let x=d; x<=end; x++) days.push(x);
            blocks.push({ start:d, end:end, days });
            d = end + 1;
        }
        return blocks;
    }

    // ----------------------------
    // Template generator
    // ----------------------------
    function createWeekTemplate(len, monthDays, sched, dailyNeeds, rollingEmps, jokerEmps) {
        // Template: { rolling:{empId:[shift...]}, joker:{empId:[shift...]}}
        const tpl = { rolling:{}, joker:{} };

        // Build local "needs snapshot" for this week (copy only)
        const need = {};
        monthDays.forEach(day => {
            need[day] = { M: dailyNeeds[day].M, A: dailyNeeds[day].A, N: dailyNeeds[day].N };
        });

        // Pre-plan OFF days for rolling (aim 2/week scaled if partial)
        const offTarget = Math.max(1, Math.round(2 * (len/7)));
        const rollingOff = {};
        rollingEmps.forEach((emp, idx) => {
            rollingOff[emp.id] = pickOffDays(monthDays, need, offTarget, idx);
        });

        // Joker OFF: exactly 1 per week (or 1 if partial too)
        const jokerOff = {};
        jokerEmps.forEach((emp, idx) => {
            jokerOff[emp.id] = pickOffDays(monthDays, need, 1, idx+100); // different offset
        });

        // Rolling buckets scaled for partial weeks
        const scaledBuckets = {};
        rollingEmps.forEach(emp => {
            const f = emp.flexCounts || { M:1, A:2, N:2, OFF:2 };
            scaledBuckets[emp.id] = scaleBucketToLen(f, len);
        });

        // Init arrays
        rollingEmps.forEach(emp => tpl.rolling[emp.id] = Array(len).fill("OFF"));
        jokerEmps.forEach(emp => tpl.joker[emp.id] = Array(len).fill("OFF"));

        // Assign OFF days in template
        monthDays.forEach((day, i) => {
            rollingEmps.forEach(emp => {
                if(rollingOff[emp.id].includes(day)) tpl.rolling[emp.id][i] = "OFF";
            });
            jokerEmps.forEach(emp => {
                if(jokerOff[emp.id].includes(day)) tpl.joker[emp.id][i] = "OFF";
            });
        });

        // Per day: fill deficits using tiered logic (template-level)
        // We'll try to cover M/A first with rolling, then N with joker/rolling.
        monthDays.forEach((day, i) => {
            // Build list of rolling available this day (not OFF)
            const availRolling = rollingEmps.filter(emp => tpl.rolling[emp.id][i] !== "OFF");
            shuffleInPlace(availRolling);

            // Tier 2: Rolling Happy Path (match bucket + deficit)
            const order = ["M","A","N"];
            order.forEach(s => {
                availRolling.forEach(emp => {
                    if(tpl.rolling[emp.id][i] !== "OFF") {
                        // if already assigned, skip
                        if(isWorkShift(tpl.rolling[emp.id][i])) return;
                        if(need[day][s] <= 0) return;
                        if(scaledBuckets[emp.id][s] <= 0) return;
                        tpl.rolling[emp.id][i] = s;
                        scaledBuckets[emp.id][s]--;
                        need[day][s]--;
                    }
                });
            });

            // Tier 3: Rolling Morning Force (steal from A/N if M deficit)
            if(need[day].M > 0) {
                availRolling.forEach(emp => {
                    if(isWorkShift(tpl.rolling[emp.id][i])) return;
                    if(need[day].M <= 0) return;
                    if(scaledBuckets[emp.id].A > 0) { tpl.rolling[emp.id][i] = "M"; scaledBuckets[emp.id].A--; need[day].M--; }
                    else if(scaledBuckets[emp.id].N > 0) { tpl.rolling[emp.id][i] = "M"; scaledBuckets[emp.id].N--; need[day].M--; }
                });
            }

            // Tier 4: Rolling cleanup (use remaining bucket even if no deficit)
            availRolling.forEach(emp => {
                if(isWorkShift(tpl.rolling[emp.id][i])) return;
                // Prefer N then A then M (leave M for real deficits later)
                if(scaledBuckets[emp.id].N > 0) { tpl.rolling[emp.id][i] = "N"; scaledBuckets[emp.id].N--; }
                else if(scaledBuckets[emp.id].A > 0) { tpl.rolling[emp.id][i] = "A"; scaledBuckets[emp.id].A--; }
                else if(scaledBuckets[emp.id].M > 0) { tpl.rolling[emp.id][i] = "M"; scaledBuckets[emp.id].M--; }
            });

            // Jokers: Tier 5 fill remaining gaps (priority N -> A -> M)
            const availJoker = jokerEmps.filter(emp => tpl.joker[emp.id][i] !== "OFF");
            shuffleInPlace(availJoker);
            ["N","A","M"].forEach(s => {
                availJoker.forEach(emp => {
                    if(isWorkShift(tpl.joker[emp.id][i])) return;
                    if(need[day][s] <= 0) return;
                    tpl.joker[emp.id][i] = s;
                    need[day][s]--;
                });
            });

            // Joker idle: if still not assigned and not OFF, prefer N then A then M
            availJoker.forEach(emp => {
                if(isWorkShift(tpl.joker[emp.id][i])) return;
                tpl.joker[emp.id][i] = "N";
            });
        });

        return tpl;
    }

    function pickOffDays(days, need, count, seed) {
        // choose lowest-need days to place OFF, with slight offset to avoid clustering
        const scored = days.map((d, idx) => {
            const score = (need[d].M + need[d].A + need[d].N) * 10 + ((idx + seed) % 3); // tiny tie-breaker
            return { d, score };
        }).sort((a,b)=>a.score-b.score);

        const chosen = [];
        for(let i=0; i<scored.length && chosen.length<count; i++) {
            const day = scored[i].d;
            // avoid consecutive OFF if possible
            const prev = chosen[chosen.length-1];
            if(prev && Math.abs(prev - day) === 1) continue;
            chosen.push(day);
        }
        // if still not enough, fill any
        for(let i=0; i<scored.length && chosen.length<count; i++) {
            const day = scored[i].d;
            if(!chosen.includes(day)) chosen.push(day);
        }
        return chosen.slice(0, count);
    }

    function scaleBucketToLen(flex, len) {
        // Scale M/A/N/OFF from 7-day expectation to partial week length.
        const base = { M:flex.M||0, A:flex.A||0, N:flex.N||0, OFF:flex.OFF||0 };
        const ratio = len / 7;
        let scaled = {
            M: Math.max(0, Math.round(base.M * ratio)),
            A: Math.max(0, Math.round(base.A * ratio)),
            N: Math.max(0, Math.round(base.N * ratio)),
            OFF: Math.max(0, Math.round(base.OFF * ratio)),
        };

        // Ensure OFF at least 1, and ~2/week preference
        const offPref = Math.max(1, Math.round(2 * ratio));
        scaled.OFF = Math.max(scaled.OFF, offPref);

        // Fix sum to len by adjusting work shifts first
        let sum = scaled.M + scaled.A + scaled.N + scaled.OFF;
        while(sum > len) {
            // reduce N then A then M then OFF (last resort)
            if(scaled.N > 0) scaled.N--;
            else if(scaled.A > 0) scaled.A--;
            else if(scaled.M > 0) scaled.M--;
            else if(scaled.OFF > 1) scaled.OFF--;
            sum--;
        }
        while(sum < len) {
            // add A then N then M (avoid too many mornings)
            if(scaled.A < 5) scaled.A++;
            else if(scaled.N < 5) scaled.N++;
            else scaled.M++;
            sum++;
        }
        return scaled;
    }

    function shuffleInPlace(arr) {
        for(let i=arr.length-1;i>0;i--){
            const j = Math.floor(Math.random()*(i+1));
            [arr[i],arr[j]]=[arr[j],arr[i]];
        }
    }

    // ----------------------------
    // Apply template to month with Safety + Max6
    // ----------------------------
    function applyWeekTemplate(monthDays, tpl, sched, dailyNeeds, rollingEmps, jokerEmps, streaks, prevShift) {
        // Rolling
        rollingEmps.forEach(emp => {
            monthDays.forEach((day, i) => {
                if(sched[emp.id][day] && sched[emp.id][day].shift) return; // fixed/VAC already set
                const proposed = tpl.rolling[emp.id] ? tpl.rolling[emp.id][i] : "OFF";
                applyOne(emp, day, proposed, sched, dailyNeeds, streaks, prevShift);
            });
        });
        // Joker
        jokerEmps.forEach(emp => {
            monthDays.forEach((day, i) => {
                if(sched[emp.id][day] && sched[emp.id][day].shift) return;
                const proposed = tpl.joker[emp.id] ? tpl.joker[emp.id][i] : "OFF";
                applyOne(emp, day, proposed, sched, dailyNeeds, streaks, prevShift);
            });
        });
    }

    function applyOne(emp, day, proposed, sched, dailyNeeds, streaks, prevShift) {
        // If VAC already exists, keep it
        if(sched[emp.id][day] && sched[emp.id][day].shift === "VAC") {
            // VAC counts in streak (only OFF breaks)
            if(prevShift[emp.id] !== "OFF") streaks[emp.id]++; else streaks[emp.id]=1;
            prevShift[emp.id] = "VAC";
            return;
        }

        // Enforce max 6 consecutive: ONLY OFF breaks
        if(streaks[emp.id] >= MAX_CONSECUTIVE) {
            // must be OFF
            setShiftRaw(emp, day, "OFF", sched, dailyNeeds, streaks, prevShift);
            return;
        }

        // Safety gate: avoid flip
        let s = proposed;
        if(isShiftFlipViolation(prevShift[emp.id], s)) {
            // Try alternatives by priority:
            // For joker prefer N->A->M, for rolling prefer keep day OFF then A/N then M
            const alt = emp.patternType === "joker"
                ? ["N","A","M","OFF"]
                : ["OFF","A","N","M"];
            s = "OFF";
            for(const cand of alt) {
                if(cand === proposed) continue;
                if(cand !== "OFF" && isShiftFlipViolation(prevShift[emp.id], cand)) continue;
                s = cand;
                break;
            }
        }

        setShiftRaw(emp, day, s, sched, dailyNeeds, streaks, prevShift);
    }

    function setShiftRaw(emp, day, s, sched, dailyNeeds, streaks, prevShift) {
        sched[emp.id][day] = { shift: s, depot: "" };
        // decrement needs only if work shift and still positive
        if(isWorkShift(s) && dailyNeeds[day] && dailyNeeds[day][s] > 0) dailyNeeds[day][s]--;

        // streak: ONLY OFF breaks
        if(s === "OFF") streaks[emp.id] = 0;
        else streaks[emp.id] = (streaks[emp.id] || 0) + 1;

        prevShift[emp.id] = s;
    }

    // ----------------------------
    // Patch deficits per week (light touch)
    // ----------------------------
    function patchDayDeficits(monthDays, sched, dailyNeeds, rollingEmps, jokerEmps, streaks, prevShift) {
        // For each day: if deficit exists, try to move OFF->work from joker first, then rolling.
        monthDays.forEach(day => {
            const needs = dailyNeeds[day];
            if(!needs) return;

            // Try fill N then A then M
            ["N","A","M"].forEach(shift => {
                while(needs[shift] > 0) {
                    // candidate 1: joker who is OFF today and can safely take shift
                    let cand = findOffCandidate(jokerEmps, day, shift, sched);
                    if(!cand) cand = findOffCandidate(rollingEmps, day, shift, sched);
                    if(!cand) break;

                    // apply with proper enforcement (max6/safety)
                    // Note: this will also reduce needs
                    applyOne(cand, day, shift, sched, dailyNeeds, streaks, prevShift);

                    // if still didn't reduce (blocked by max6/safety), stop to avoid infinite loop
                    if(needs[shift] > 0 && (sched[cand.id][day].shift !== shift)) break;
                }
            });
        });
    }

    function findOffCandidate(list, day, shift, sched) {
        for(const emp of list) {
            const cell = sched[emp.id][day];
            if(!cell || !cell.shift) continue;
            if(cell.shift !== "OFF") continue;
            // don't override VAC
            if(cell.shift === "VAC") continue;
            // don't allow if previous day causes flip (we'll check in applyOne anyway)
            return emp;
        }
        return null;
    }

    // ----------------------------
    // Final enforcement
    // ----------------------------
    function enforceSafetyAndMax6(numDays, sched) {
        state.employees.forEach(emp => {
            let prev = "OFF";
            let streak = 0;
            for(let d=1; d<=numDays; d++) {
                const cell = sched[emp.id][d];
                if(!cell || !cell.shift) {
                    sched[emp.id][d] = { shift:"OFF", depot:"" };
                }
                const s = sched[emp.id][d].shift;

                // VAC override always
                if(s === "VAC") {
                    // streak does NOT break
                    streak = streak + 1;
                    prev = "VAC";
                    continue;
                }

                // Max 6: ONLY OFF breaks
                if(streak >= MAX_CONSECUTIVE && s !== "OFF") {
                    sched[emp.id][d].shift = "OFF";
                }

                // Safety flip: if violation, turn into OFF (do not touch VAC)
                const curr = sched[emp.id][d].shift;
                if(isShiftFlipViolation(prev, curr)) {
                    sched[emp.id][d].shift = "OFF";
                }

                // update trackers
                const finalS = sched[emp.id][d].shift;
                if(finalS === "OFF") streak = 0;
                else streak = streak + 1;

                prev = finalS;
            }
        });
    }

    // ===========================
    // Scheduling Helpers (existing)
    // ===========================
    function isAssigned(emp, d, sched) { return !!(sched[emp.id] && sched[emp.id][d]); }

    function applyVacations(numDays, sched) {
        state.employees.forEach(emp => {
            if(!emp.vacationDates) return;
            emp.vacationDates
                .split(',')
                .map(d=>parseInt(d.trim()))
                .filter(d=>!isNaN(d))
                .forEach(d => {
                    if(d<=numDays) sched[emp.id][d] = { shift: 'VAC', depot: '' };
                });
        });
    }

    function calculateDailyNeeds(numDays) {
        const needs = {};
        const depots = appConfig.depots.map(d=>d.trim());
        const reqs = state.meta.requirements || {};
        for(let d=1; d<=numDays; d++) {
            needs[d] = { M:0, A:0, N:0 };
            depots.forEach(dep => {
                const r = reqs[dep] || {};
                needs[d].M += (r.M||0);
                needs[d].A += (r.A||0);
                needs[d].N += (r.N||0);
            });
        }
        return needs;
    }

    function applyFixedEmployees(numDays, sched, dailyNeeds, streaks, prevs) {
        state.employees.filter(e => e.patternType === 'weekly').forEach(emp => {
            for(let d=1; d<=numDays; d++) {
                // keep VAC if set
                if(sched[emp.id][d] && sched[emp.id][d].shift === "VAC") {
                    // streak ONLY breaks on OFF
                    streaks[emp.id] = (streaks[emp.id] || 0) + 1;
                    prevs[emp.id] = "VAC";
                    continue;
                }

                const dayOfWeek = new Date(appConfig.year, appConfig.month-1, d).getDay();
                let shift = emp.weeklyTemplate[dayOfWeek];
                const prev = prevs[emp.id];

                // enforce max6 (only OFF breaks)
                if(streaks[emp.id] >= MAX_CONSECUTIVE && shift !== "OFF") shift = "OFF";
                // enforce flip
                if(isShiftFlipViolation(prev, shift)) shift = "OFF";

                // set
                sched[emp.id][d] = { shift: shift, depot:"" };

                // needs
                if(isWorkShift(shift) && dailyNeeds[d][shift] > 0) dailyNeeds[d][shift]--;

                // streak
                if(shift === "OFF") streaks[emp.id] = 0;
                else streaks[emp.id] = (streaks[emp.id] || 0) + 1;

                prevs[emp.id] = shift;
            }
        });
    }

    // ===========================
    // DEPOT FILL (unchanged)
    // ===========================
    function fillDepots() {
        const key = getMonthKey();
        const sched = state.schedule[key];
        if(!sched || !confirm("ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ØŸ")) return;
        const numDays = daysInMonth(appConfig.year, appConfig.month);
        const reqs = state.meta.requirements || {};
        const depots = appConfig.depots.map(d=>d.trim());

        for(let d=1; d<=numDays; d++) {
            state.employees.forEach(e => {
                if(sched[e.id][d] && ['M','A','N'].includes(sched[e.id][d].shift)) sched[e.id][d].depot = "";
            });
        }

        for(let d=1; d<=numDays; d++) {
            const counts = {}; depots.forEach(dp=>counts[dp]={M:0,A:0,N:0});
            const workers = {M:[],A:[],N:[]};
            state.employees.forEach(e => {
                let s = sched[e.id][d].shift;
                if(['M','A','N'].includes(s)) workers[s].push(e);
            });

            ['M','A','N'].forEach(s => {
                let list = workers[s];
                list.sort((a,b) => ((b.depotQuotas[depots[0]]||0) - (a.depotQuotas[depots[0]]||0)));
                depots.forEach(dep => {
                    let need = (reqs[dep]||{})[s] || 0;
                    let i = 0;
                    while(i<list.length && counts[dep][s] < need) {
                        let e = list[i];
                        if(!sched[e.id][d].depot) { sched[e.id][d].depot = dep; counts[dep][s]++; }
                        i++;
                    }
                });
                list.forEach(e => {
                    if(!sched[e.id][d].depot) {
                        let target = depots.reduce((a,b)=>counts[a][s]<counts[b][s]?a:b);
                        sched[e.id][d].depot = target; counts[target][s]++;
                    }
                });
            });
        }
        renderSchedule(); saveData();
    }

    // ===========================
    // RENDER schedule (unchanged)
    // ===========================
    function renderSchedule() {
        const grid = document.getElementById('scheduleGrid');
        if(!grid) return;
        const numDays = daysInMonth(appConfig.year, appConfig.month);
        const data = state.schedule[getMonthKey()] || {};
        let html = `<thead><tr><th class="emp-col">Ø§Ù„Ù…ÙˆØ¸Ù</th>`;
        for(let d=1; d<=numDays; d++) html += `<th>${d}<br>${WEEKDAYS[new Date(appConfig.year,appConfig.month-1,d).getDay()]}</th>`;
        html += `</tr></thead><tbody>`;
        state.employees.forEach(e => {
            let row = `<tr><td class="emp-col">${e.name}</td>`;
            let prev='OFF';
            for(let d=1; d<=numDays; d++) {
                let c = (data[e.id] && data[e.id][d]) || {shift:''};
                let s = c.shift||'';
                let v = isShiftFlipViolation(prev, s) ? 'violation' : '';
                row += `<td class="cell shift-${s} ${v}">${s}${c.depot?`<span class="depot-tag">${c.depot}</span>`:''}</td>`;
                if(['M','A','N','VAC','X'].includes(s)) prev=s; else prev='OFF';
            }
            html += row + `</tr>`;
        });
        grid.innerHTML = html + `</tbody>`;
        analyzeCoverage();
    }

    function analyzeCoverage() {
        const report = document.getElementById('coverageReport');
        if(!report) return;
        const numDays = daysInMonth(appConfig.year, appConfig.month);
        const sched = state.schedule[getMonthKey()] || {};
        const depots = appConfig.depots.map(d=>d.trim());
        const reqs = state.meta.requirements || {};
        let issues = [];

        for(let d=1; d<=numDays; d++) {
            let counts = {}; depots.forEach(dp=>counts[dp]={M:0,A:0,N:0});
            state.employees.forEach(e => {
                let c = sched[e.id] && sched[e.id][d];
                if(c && c.depot && ['M','A','N'].includes(c.shift)) counts[c.depot.trim()][c.shift]++;
            });
            depots.forEach(dep => {
                let r = reqs[dep] || {};
                ['M','A','N'].forEach(s => {
                    let req = r[s]||0;
                    let act = counts[dep][s]||0;
                    if(act < req) issues.push(`ÙŠÙˆÙ… ${d} ${dep} (${s}): Ù…Ø·Ù„ÙˆØ¨ ${req}ØŒ Ù…ÙˆØ¬ÙˆØ¯ ${act}`);
                });
            });
        }

        report.innerHTML = issues.length ? issues.map(i=>`<div class="report-item">${i}</div>`).join('') : `<div class="report-ok">âœ… Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù…Ù…ØªØ§Ø²!</div>`;
    }

    // ===========================
    // UTILS (unchanged)
    // ===========================
    function getMonthKey() { return `${appConfig.year}-${appConfig.month}`; }
    function daysInMonth(y, m) { return new Date(y, m, 0).getDate(); }
    function clearMonth() { if(confirm('Ù…Ø³Ø­ØŸ')) { state.schedule[getMonthKey()] = {}; renderSchedule(); saveData(); } }
    function showLoader(s) { document.getElementById('loader').style.display = s ? 'flex' : 'none'; }
    function exportCSV() {
        const numDays = daysInMonth(appConfig.year, appConfig.month);
        let csv = "\uFEFFM,";
        for(let d=1; d<=numDays; d++) csv += `${d},`; csv += "\n";
        let data = state.schedule[getMonthKey()] || {};
        state.employees.forEach(e => {
            csv += `"${e.name}",`;
            for(let d=1; d<=numDays; d++) {
                let c = (data[e.id] && data[e.id][d]) || {};
                csv += `"${c.shift||''} ${c.depot||''}",`;
            }
            csv += "\n";
        });
        const blob = new Blob([csv], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'schedule.csv'; a.click();
    }
</script>
</body>
</html>
