<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© (V10.1 - Ø¥ØµÙ„Ø§Ø­ OFF Ø§Ù„Ø¯ÙˆÙ‘Ø§Ø±)</title>
  <style>
    :root { --primary: #2563eb; --success: #10b981; --danger: #ef4444; --warning: #f59e0b; --bg: #f8fafc; --border: #cbd5e1; }
    * { box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: var(--bg); font-size: 13.5px; direction: rtl; }
    .app-container { max-width: 1400px; margin: 0 auto; padding: 10px; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 10px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 20px; align-items: center; }
    h1 { margin: 0; font-size: 1.3rem; margin-left: auto; color: #1e293b; font-weight: 800; }
    button { cursor: pointer; padding: 8px 16px; border: 1px solid var(--border); background: white; border-radius: 6px; font-weight: 600; transition: all 0.2s; font-family: inherit; }
    button:hover { transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    button.primary { background: var(--primary); color: white; border-color: var(--primary); }
    button.success { background: var(--success); color: white; border-color: var(--success); }
    button.danger { background: var(--danger); color: white; border-color: var(--danger); }
    input, select { padding: 8px; border: 1px solid var(--border); border-radius: 5px; font-family: inherit; }
    .tabs { display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 2px solid #e2e8f0; background: white; border-radius: 8px 8px 0 0; padding: 0 10px; }
    .tab { padding: 12px 24px; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; color: #64748b; font-weight: 600; }
    .tab:hover { background: #f8fafc; color: var(--primary); }
    .tab.active { border-bottom-color: var(--primary); color: var(--primary); }
    .view { display: none; }
    .view.active { display: block; }

    .grid-container { overflow-x: auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); border: 1px solid var(--border); }
    .schedule-table { border-collapse: collapse; width: 100%; min-width: 1000px; table-layout: fixed; }
    .schedule-table th, .schedule-table td { border: 1px solid #e2e8f0; text-align: center; padding: 4px; height: 42px; font-size: 0.85rem; vertical-align: middle; }
    .schedule-table th { background: #f8fafc; position: sticky; top: 0; z-index: 10; font-weight: 700; color: #334155; white-space: nowrap; }
    .schedule-table th.emp-col { position: sticky; right: 0; z-index: 20; width: 190px; text-align: right; padding-right: 12px; border-left: 2px solid #cbd5e1; background: #f8fafc; }
    .schedule-table td.emp-col { position: sticky; right: 0; z-index: 5; background: white; text-align: right; padding-right: 12px; font-weight: 700; border-left: 2px solid #cbd5e1; color: #1e293b; }

    .cell { cursor: pointer; user-select: none; transition: background 0.15s; font-weight: 700; line-height: 1.1; }
    .cell:hover { filter: brightness(0.95); }
    .cell.shift-M { background-color: #dbeafe; color: #1e40af; }
    .cell.shift-A { background-color: #fef3c7; color: #92400e; }
    .cell.shift-N { background-color: #1e293b; color: #f8fafc; }
    .cell.shift-OFF { background-color: #f0fdf4; color: #166534; }
    .cell.shift-VAC { background-color: #f3e8ff; color: #7e22ce; }
    .cell.shift-X { background-color: #fee2e2; color: #991b1b; }
    .violation { outline: 3px solid var(--danger) !important; outline-offset: -2px; border-radius: 6px; }

    .emp-card { border: 1px solid var(--border); background: white; padding: 16px; border-radius: 10px; margin-bottom: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .emp-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px; border-bottom: 1px solid #f1f5f9; margin-bottom: 12px; gap: 8px; }
    .pattern-editor { background: #f8fafc; padding: 12px; border-radius: 8px; border: 1px dashed var(--border); margin-top: 10px; }
    .flex-counts { display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; }
    .flex-counts div { display: flex; flex-direction: column; align-items: center; }
    .flex-counts label { font-size: 0.7rem; font-weight: 800; color: #64748b; }
    .flex-counts input { width: 52px; text-align: center; font-weight: 800; border: 1px solid #cbd5e1; border-radius: 6px; padding: 6px; }

    .depot-quotas { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; margin-top: 10px; }
    .depot-quotas div { background: #fff7ed; padding: 6px; border: 1px solid #ffedd5; border-radius: 6px; }
    .depot-quotas label { font-size: 0.7rem; font-weight: 800; color: #9a3412; display: block; }
    .depot-quotas input { width: 100%; text-align: center; font-weight: 800; margin-top: 2px; border-radius: 6px; }

    .vacation-input { background: #f3e8ff; padding: 8px; border-radius: 6px; border: 1px solid #e9d5ff; margin-top: 10px; }
    .vacation-input input { width: 100%; padding: 8px; border: 1px solid #d8b4fe; border-radius: 6px; font-weight: 700; }

    #loader { position: fixed; inset: 0; background: rgba(255,255,255,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; }
    .report-box { margin-top: 20px; padding: 16px; background: white; border: 1px solid var(--border); border-radius: 10px; }
    .report-item { margin-bottom: 6px; padding: 8px 10px; background: #fff1f2; color: #9f1239; border-radius: 6px; border-right: 4px solid var(--danger); font-size: 0.9rem; font-weight: 700; }
    .report-ok { background: #d1fae5; color: #065f46; padding: 15px; text-align: center; font-weight: 900; border-radius: 8px; }
    .alert-box { background: #dbeafe; border: 1px solid #93c5fd; padding: 12px; border-radius: 8px; margin: 10px 0; color: #1e40af; font-weight: 800; font-size: 0.9rem; text-align: center; }
    .req-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .req-table th, .req-table td { border: 1px solid #e2e8f0; padding: 8px; text-align: center; font-weight: 800; }
    .req-input { width: 70px; text-align: center; font-weight: 900; border-radius: 6px; }

    .depot-tag { display:block; font-size: 0.72rem; opacity: .9; margin-top: 2px; font-weight: 800; }
  </style>
</head>
<body>

<div id="loader">
  <div style="font-size: 2.5rem;">ğŸ—ï¸</div>
  <div style="margin-top: 10px; font-weight: 900; color:#334155;">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ù…Ø¹ Balanced OFF...</div>
</div>

<div class="app-container">
  <div class="toolbar">
    <h1>ğŸ—“ï¸ Ù†Ø¸Ø§Ù… Ø§Ù„Ø³ÙŠØ¯Ø© Ø²ÙŠÙ†Ø¨ (V10.1 - Ø¥ØµÙ„Ø§Ø­ Ø¥Ø¬Ø§Ø²Ø§Øª Ø§Ù„Ø¯ÙˆÙ‘Ø§Ø±)</h1>
    <select id="selYear"></select>
    <select id="selMonth"></select>
    <button onclick="loadData()">ğŸ”„ ØªØ­Ø¯ÙŠØ«</button>
    <button class="primary" onclick="saveData()">ğŸ’¾ Ø­ÙØ¸</button>
    <div style="flex-grow:1; text-align:left; font-size:0.8rem; color:#64748b;">
      <span id="lastUpdated"></span>
    </div>
  </div>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('schedule', event)">Ø§Ù„Ø¬Ø¯ÙˆÙ„</div>
    <div class="tab" onclick="switchTab('employees', event)">Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ†</div>
    <div class="tab" onclick="switchTab('settings', event)">Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</div>
  </div>

  <div id="view-schedule" class="view active">
    <div class="alert-box">
      âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: <strong>OFF Ù„Ù„Ø¯ÙˆÙ‘Ø§Ø± ØµØ§Ø± Ù…ÙˆØ²ÙˆÙ† Ø¯Ø§Ø®Ù„ ÙƒÙ„ Ø£Ø³Ø¨ÙˆØ¹</strong> (Ø§Ù„Ø£Ø­Ø¯â†’Ø§Ù„Ø³Ø¨Øª) Ù„Ù…Ù†Ø¹ ØªØ¬Ù…Ù‘Ø¹ Ø§Ù„Ø¥Ø¬Ø§Ø²Ø§Øª.
    </div>
    <div class="toolbar" style="background:transparent; padding:0; box-shadow:none; justify-content:space-between;">
      <div>
        <button onclick="generateScheduleV101()" class="primary">âš¡ ØªÙˆØ²ÙŠØ¹ (V10.1)</button>
        <button onclick="fillDepots()" class="success">ğŸ­ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹</button>
      </div>
      <div>
        <button onclick="clearMonth()" class="danger">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
        <button onclick="exportCSV()">ğŸ“„ Excel</button>
      </div>
    </div>

    <div class="grid-container">
      <table class="schedule-table" id="scheduleGrid"></table>
    </div>

    <div id="coverageReport" class="report-box"></div>
  </div>

  <div id="view-employees" class="view">
    <button class="primary" onclick="addEmployee()" style="margin-bottom: 15px;">â• Ø¥Ø¶Ø§ÙØ© Ù…ÙˆØ¸Ù</button>
    <div id="employeeList"></div>
  </div>

  <div id="view-settings" class="view">
    <div class="emp-card">
      <h3>1ï¸âƒ£ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ (Depots)</h3>
      <input type="text" id="settingDepots" style="width: 100%;" onchange="updateDepots()">
    </div>
    <div class="emp-card">
      <h3>2ï¸âƒ£ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (M, A, N)</h3>
      <div id="requirementsContainer"></div>
    </div>
    <div class="emp-card">
      <h3>3ï¸âƒ£ ØªØ­ÙƒÙ…</h3>
      <button class="danger" onclick="saveData(true)">âš ï¸ ØªØµÙÙŠØ± Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
    </div>
  </div>
</div>

<script>
  // ==========================================
  // === CONFIGURATION ===
  // ==========================================
  const API_URL = "https://script.google.com/macros/s/AKfycbz_Ax4qk6l7tmebex2kP9e2KCz4twS960mH5D2JxF8RIa0h_OeiAC96uTNSMunQrvha/exec";

  // ==========================================
  // === STATE & CONSTANTS ===
  // ==========================================
  let state = {
    employees: [],
    schedule: {},
    meta: { requirements: {}, depots: [], updatedAt: null }
  };

  let appConfig = {
    depots: ["Budaiya", "IsaTown"],
    year: new Date().getFullYear(),
    month: new Date().getMonth() + 1
  };

  const SHIFTS = ["M", "A", "N", "OFF", "VAC", "X"];
  const WEEKDAYS = ["Ø£Ø­Ø¯", "Ø§Ø«Ù†ÙŠÙ†", "Ø«Ù„Ø§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®Ù…ÙŠØ³", "Ø¬Ù…Ø¹Ø©", "Ø³Ø¨Øª"];
  const MAX_CONSECUTIVE = 6;

  // ==========================================
  // === RULES ===
  // ==========================================
  function isShiftFlipViolation(prev, next) {
    if (!prev || ['OFF', 'X', 'VAC'].includes(prev)) return false;
    if (next === 'OFF' || next === 'X' || next === 'VAC') return false;
    if (prev === 'N') return (next === 'M' || next === 'A');
    if (prev === 'A') return (next === 'M');
    return false;
  }

  // NOTE: Ø­Ø³Ø¨ ÙƒÙ„Ø§Ù…Ùƒ "ÙÙ‚Ø· OFF ÙŠÙƒØ³Ø± Ø§Ù„Ø³ØªØ±ÙŠÙƒ"
  function streakBreaks(shift) {
    return shift === 'OFF';
  }

  // ==========================================
  // === INIT ===
  // ==========================================
  window.onload = () => { initDateSelectors(); loadData(); };

  function initDateSelectors() {
    const ySel = document.getElementById('selYear');
    const mSel = document.getElementById('selMonth');
    const curr = new Date().getFullYear();

    for (let y = curr - 1; y <= curr + 2; y++) ySel.add(new Option(y, y));
    ySel.value = curr;

    ["ÙŠÙ†Ø§ÙŠØ±","ÙØ¨Ø±Ø§ÙŠØ±","Ù…Ø§Ø±Ø³","Ø£Ø¨Ø±ÙŠÙ„","Ù…Ø§ÙŠÙˆ","ÙŠÙˆÙ†ÙŠÙˆ","ÙŠÙˆÙ„ÙŠÙˆ","Ø£ØºØ³Ø·Ø³","Ø³Ø¨ØªÙ…Ø¨Ø±","Ø£ÙƒØªÙˆØ¨Ø±","Ù†ÙˆÙÙ…Ø¨Ø±","Ø¯ÙŠØ³Ù…Ø¨Ø±"]
      .forEach((m, i) => mSel.add(new Option(m, i + 1)));

    mSel.value = new Date().getMonth() + 1;

    ySel.onchange = () => { appConfig.year = parseInt(ySel.value); renderSchedule(); };
    mSel.onchange = () => { appConfig.month = parseInt(mSel.value); renderSchedule(); };
  }

  function switchTab(t, ev) {
    document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
    document.querySelectorAll('.view').forEach(x => x.classList.remove('active'));
    ev.target.classList.add('active');
    document.getElementById(`view-${t}`).classList.add('active');
  }

  // ==========================================
  // === API ===
  // ==========================================
  async function loadData() {
    showLoader(true);
    try {
      const res = await fetch(`${API_URL}?action=load`);
      const json = await res.json();
      if (json.ok) {
        const data = json.data || {};
        state.employees = data.employees || [];
        state.schedule = data.schedule || {};
        state.meta = data.meta || { requirements: {}, depots: [], updatedAt: null };

        if (state.meta.depots && state.meta.depots.length) appConfig.depots = state.meta.depots;
        document.getElementById('settingDepots').value = appConfig.depots.join(', ');

        // Normalize employee defaults
        state.employees.forEach(emp => {
          if (!emp.id) emp.id = 'emp_' + Math.random().toString(36).slice(2, 9);
          if (!emp.patternType) emp.patternType = 'weekly';
          if (!emp.weeklyTemplate) emp.weeklyTemplate = Array(7).fill("M");
          if (!emp.flexCounts) emp.flexCounts = { M: 1, A: 2, N: 2, OFF: 2 };
          if (!emp.depotQuotas) emp.depotQuotas = {};
          if (!emp.vacationDates) emp.vacationDates = "";
        });

        // Normalize requirements keys if needed
        const reqs = state.meta.requirements || {};
        for (let d in reqs) {
          if (reqs[d].D !== undefined) {
            reqs[d].M = reqs[d].D; reqs[d].A = reqs[d].EN; reqs[d].N = reqs[d].LN;
            delete reqs[d].D; delete reqs[d].EN; delete reqs[d].LN;
          }
        }

        renderEmployees();
        renderRequirementsTable();
        renderSchedule();

        if (state.meta.updatedAt) {
          document.getElementById('lastUpdated').innerText = new Date(state.meta.updatedAt).toLocaleTimeString();
        } else {
          document.getElementById('lastUpdated').innerText = "";
        }
      }
    } catch (e) {
      console.error(e);
      alert("ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„.");
    } finally {
      showLoader(false);
    }
  }

  async function saveData(reset = false) {
    showLoader(true);
    if (reset && !confirm("âš ï¸ Ù…Ø³Ø­ Ø§Ù„ÙƒÙ„ØŸ")) { showLoader(false); return; }

    if (reset) state = { employees: [], schedule: {}, meta: { requirements: {}, depots: [], updatedAt: null } };

    state.meta.depots = appConfig.depots;
    state.meta.updatedAt = new Date().toISOString();

    try {
      await fetch(API_URL, {
        method: "POST",
        body: JSON.stringify({
          action: "save",
          payload: { employees: state.employees, schedule: state.schedule, meta: state.meta }
        })
      });

      if (reset) {
        renderEmployees();
        renderRequirementsTable();
        renderSchedule();
        document.getElementById('settingDepots').value = "Budaiya, IsaTown";
      }

      document.getElementById('lastUpdated').innerText = new Date().toLocaleTimeString();
    } catch (e) {
      alert("Ø®Ø·Ø£ Ø­ÙØ¸.");
    } finally {
      showLoader(false);
    }
  }

  // ==========================================
  // === UI: Requirements ===
  // ==========================================
  function renderRequirementsTable() {
    const container = document.getElementById('requirementsContainer');
    if (!container) return;
    if (!state.meta.requirements) state.meta.requirements = {};

    let html = `<table class="req-table"><thead><tr><th>Ø§Ù„Ù…ÙˆÙ‚Ø¹</th><th>M</th><th>A</th><th>N</th></tr></thead><tbody>`;
    appConfig.depots.forEach(depot => {
      const req = state.meta.requirements[depot] || { M: 0, A: 0, N: 0 };
      html += `<tr>
        <td style="font-weight:900;">${depot}</td>
        <td><input type="number" min="0" class="req-input" value="${req.M || 0}" onchange="updateReq('${depot}', 'M', this.value)"></td>
        <td><input type="number" min="0" class="req-input" value="${req.A || 0}" onchange="updateReq('${depot}', 'A', this.value)"></td>
        <td><input type="number" min="0" class="req-input" value="${req.N || 0}" onchange="updateReq('${depot}', 'N', this.value)"></td>
      </tr>`;
    });
    container.innerHTML = html + `</tbody></table>`;
  }

  function updateReq(depot, shift, value) {
    if (!state.meta.requirements[depot]) state.meta.requirements[depot] = {};
    state.meta.requirements[depot][shift] = parseInt(value) || 0;
  }

  // ==========================================
  // === UI: Employees ===
  // ==========================================
  function renderEmployees() {
    const container = document.getElementById('employeeList');
    container.innerHTML = "";

    state.employees.forEach(emp => {
      const div = document.createElement('div');
      div.className = "emp-card";

      // Weekly template editor (for fixed)
      let weekHtml = "<div style='display:grid; grid-template-columns:repeat(7,1fr); gap:6px;'>";
      WEEKDAYS.forEach((day, i) => {
        const opts = SHIFTS
          .filter(s => s !== 'VAC' && s !== 'X')
          .map(s => `<option value="${s}" ${emp.weeklyTemplate[i] === s ? 'selected' : ''}>${s}</option>`)
          .join('');
        weekHtml += `<div style="text-align:center;">
          <label style="font-size:0.72rem; color:#64748b; font-weight:900;">${day}</label>
          <select onchange="updateWeeklyTemplate('${emp.id}', ${i}, this.value)" style="width:100%; font-size:0.9rem; font-weight:800;">${opts}</select>
        </div>`;
      });
      weekHtml += "</div>";

      // Depot quotas editor
      let quotasHtml = `<div class="depot-quotas">`;
      appConfig.depots.forEach(depot => {
        const val = (emp.depotQuotas && emp.depotQuotas[depot]) || 0;
        quotasHtml += `<div>
          <label>${depot}</label>
          <input type="number" min="0" value="${val}" onchange="updateDepotQuota('${emp.id}', '${depot}', this.value)">
        </div>`;
      });
      quotasHtml += `</div>`;

      // Vacation editor
      let vacationHtml = `
        <div class="vacation-input">
          <label style="font-weight:900;">ğŸ–ï¸ Ø£ÙŠØ§Ù… Ø§Ù„Ø¥Ø¬Ø§Ø²Ø§Øª (Ù…Ø«Ø§Ù„: 5, 6)</label>
          <input type="text" value="${emp.vacationDates || ''}" onchange="updateVacationDates('${emp.id}', this.value)">
        </div>`;

      // Pattern block
      const flex = emp.flexCounts || { M: 1, A: 2, N: 2, OFF: 2 };
      let patternHtml = "";

      if (emp.patternType === 'rolling') {
        patternHtml = `<div class="pattern-editor">
          <div style="font-weight:900; color:#0f172a; margin-bottom:8px;">ğŸ“¦ Bucket Ø£Ø³Ø¨ÙˆØ¹ÙŠ (Ø¯ÙˆÙ‘Ø§Ø±)</div>
          <div class="flex-counts">
            <div><label>OFF</label><input type="number" value="${flex.OFF}" onchange="updateFlexCount('${emp.id}', 'OFF', this.value)"></div>
            <div><label>N</label><input type="number" value="${flex.N}" onchange="updateFlexCount('${emp.id}', 'N', this.value)"></div>
            <div><label>A</label><input type="number" value="${flex.A}" onchange="updateFlexCount('${emp.id}', 'A', this.value)"></div>
            <div><label>M</label><input type="number" value="${flex.M}" onchange="updateFlexCount('${emp.id}', 'M', this.value)"></div>
          </div>
          <div style="margin-top:8px; font-size:.8rem; color:#64748b; font-weight:800;">
            âœ… OFF Ù…ÙˆØ²ÙˆÙ† Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹ Ù„Ù…Ù†Ø¹ ØªØ¬Ù…Ø¹ Ø§Ù„Ø¥Ø¬Ø§Ø²Ø§Øª.
          </div>
        </div>`;
      } else if (emp.patternType === 'joker') {
        patternHtml = `<div class="pattern-editor">
          <div style="color:#d97706; font-weight:900;">ğŸƒ Ø¬ÙˆÙƒØ±</div>
          <div style="font-size:0.85rem; font-weight:800; color:#64748b;">
            ÙŠØºØ·ÙŠ Ø§Ù„Ø¹Ø¬Ø² (N Ø£ÙˆÙ„Ø§Ù‹) Ùˆ 1 OFF Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹ (Ù…ÙˆØ²ÙˆÙ†).
          </div>
        </div>`;
      } else {
        patternHtml = `<div class="pattern-editor">
          <div style="font-weight:900; color:#0f172a; margin-bottom:8px;">ğŸ“Œ Ø«Ø§Ø¨Øª (Weekly Template)</div>
          ${weekHtml}
        </div>`;
      }

      div.innerHTML = `
        <div class="emp-header">
          <input type="text" value="${emp.name}" onchange="updateEmployee('${emp.id}', 'name', this.value)" style="font-weight:900; flex:1; border:none; outline:none; font-size:1rem;">
          <select onchange="updateEmployee('${emp.id}', 'patternType', this.value)" style="min-width:120px; font-weight:900;">
            <option value="weekly" ${emp.patternType === 'weekly' ? 'selected' : ''}>Ø«Ø§Ø¨Øª</option>
            <option value="rolling" ${emp.patternType === 'rolling' ? 'selected' : ''}>Ø¯ÙˆØ§Ø±</option>
            <option value="joker" ${emp.patternType === 'joker' ? 'selected' : ''}>Ø¬ÙˆÙƒØ±</option>
          </select>
          <button class="danger" onclick="deleteEmployee('${emp.id}')">ğŸ—‘ï¸</button>
        </div>

        ${vacationHtml}

        <div style="margin:10px 0;">
          <strong style="font-size:0.9rem; color:#64748b; font-weight:900;">ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹:</strong>
          ${quotasHtml}
        </div>

        ${patternHtml}
      `;

      container.appendChild(div);
    });
  }

  // Helpers for employees
  function addEmployee() {
    state.employees.push({
      id: 'emp_' + Math.random().toString(36).slice(2, 9),
      name: "Ø¬Ø¯ÙŠØ¯",
      patternType: "weekly",
      weeklyTemplate: Array(7).fill("M"),
      flexCounts: { M: 1, A: 2, N: 2, OFF: 2 },
      depotQuotas: {},
      vacationDates: ""
    });
    renderEmployees();
  }

  function updateEmployee(id, k, v) {
    const emp = state.employees.find(x => x.id === id);
    if (!emp) return;
    emp[k] = v;
    if (k === 'patternType') renderEmployees();
  }

  function updateWeeklyTemplate(id, i, v) {
    const emp = state.employees.find(x => x.id === id);
    if (emp) emp.weeklyTemplate[i] = v;
  }

  function updateFlexCount(id, s, v) {
    const emp = state.employees.find(x => x.id === id);
    if (!emp) return;
    if (!emp.flexCounts) emp.flexCounts = {};
    emp.flexCounts[s] = Math.max(0, parseInt(v) || 0);
  }

  function updateDepotQuota(id, depot, v) {
    const emp = state.employees.find(x => x.id === id);
    if (!emp) return;
    if (!emp.depotQuotas) emp.depotQuotas = {};
    emp.depotQuotas[depot] = Math.max(0, parseInt(v) || 0);
  }

  function updateVacationDates(id, v) {
    const emp = state.employees.find(x => x.id === id);
    if (emp) emp.vacationDates = v;
  }

  function deleteEmployee(id) {
    if (!confirm('Ø­Ø°ÙØŸ')) return;
    state.employees = state.employees.filter(x => x.id !== id);
    renderEmployees();
    renderSchedule();
    saveData();
  }

  function updateDepots() {
    appConfig.depots = document.getElementById('settingDepots').value
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);

    renderRequirementsTable();
    renderEmployees();
  }

  // ==========================================
  // === SCHEDULER: V10.1 (Balanced OFF) ===
  // ==========================================
  function generateScheduleV101() {
    if (!confirm("ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„ØªÙˆØ²ÙŠØ¹ (V10.1)ØŸ\n\n- Ø¥ØµÙ„Ø§Ø­ OFF Ù„Ù„Ø¯ÙˆÙ‘Ø§Ø± (Ù…ÙˆØ²ÙˆÙ† Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹)\n- Ø§Ù„Ø«Ø§Ø¨Øª Ø£ÙˆÙ„Ø§Ù‹\n- Ø§Ù„Ø¯ÙˆÙ‘Ø§Ø± ÙŠÙ…Ù„Ø£ M/A Ø«Ù… N\n- Ø§Ù„Ø¬ÙˆÙƒØ± ÙŠØ³Ø¯ Ø§Ù„Ø¹Ø¬Ø² (N Ø£ÙˆÙ„Ø§Ù‹)\n")) return;

    showLoader(true);

    setTimeout(() => {
      try {
        const key = getMonthKey();
        const numDays = daysInMonth(appConfig.year, appConfig.month);

        if (!state.schedule[key]) state.schedule[key] = {};
        const sched = state.schedule[key];

        state.employees.forEach(e => { if (!sched[e.id]) sched[e.id] = {}; });

        // 0) Apply vacations first (override)
        applyVacations(numDays, sched);

        // 1) Calculate daily global needs (sum of depots)
        const dailyNeeds = calculateDailyNeeds(numDays);

        // 2) Track previous shift + streak
        const prevShift = {};
        const streak = {};
        state.employees.forEach(e => { prevShift[e.id] = 'OFF'; streak[e.id] = 0; });

        // 3) Apply fixed employees for the whole month
        applyFixedEmployees(numDays, sched, dailyNeeds, streak, prevShift);

        // 4) Rolling + Joker week by week
        const rolling = state.employees.filter(e => e.patternType === 'rolling');
        const jokers  = state.employees.filter(e => e.patternType === 'joker');

        const weeks = buildWeeks(appConfig.year, appConfig.month, numDays);

        // === Balanced OFF Plans ===
        // Rolling OFF per week from their bucket.OFF (default 2)
        // Joker OFF fixed 1 per week (balanced)
        const rollingOffPlan = buildBalancedOffPlan(rolling, weeks, 2);
        const jokerOffPlan   = buildBalancedOffPlan(jokers,  weeks, 1);

        // Main loop by week
        weeks.forEach((w, wi) => {
          // Reset weekly credits every Sunday/week start (Ø­ØªÙ‰ Ù„Ùˆ Ø§Ù„Ø´Ù‡Ø± Ø¨Ø¯Ø£ Ù†Øµ Ø£Ø³Ø¨ÙˆØ¹)
          rolling.forEach(emp => {
            const f = emp.flexCounts || { M: 1, A: 2, N: 2, OFF: 2 };
            // Work credits is total work slots in week (M+A+N). OFF is handled by offPlan.
            emp._workCredits = Math.max(0, (f.M || 0) + (f.A || 0) + (f.N || 0));
          });

          for (let d = w.start; d <= w.end; d++) {
            const needs = dailyNeeds[d];

            const rollingList = [...rolling]; shuffleInPlace(rollingList);
            const jokerList   = [...jokers];  shuffleInPlace(jokerList);

            // 4.1 Rolling OFF enforcement (balanced)
            rollingList.forEach(emp => {
              if (isAssigned(emp.id, d, sched)) return; // already VAC or fixed
              if (shouldForceOff(emp.id, d, streak, rollingOffPlan, wi)) {
                setShift(emp.id, d, 'OFF', sched, prevShift, streak);
              }
            });

            // 4.2 Joker OFF enforcement (balanced)
            jokerList.forEach(emp => {
              if (isAssigned(emp.id, d, sched)) return;
              if (shouldForceOff(emp.id, d, streak, jokerOffPlan, wi)) {
                setShift(emp.id, d, 'OFF', sched, prevShift, streak);
              }
            });

            // 4.3 Rolling fills M/A (priority) respecting anti-flip
            rollingList.forEach(emp => {
              if (isAssigned(emp.id, d, sched)) return;
              if (emp._workCredits <= 0) return; // finished weekly work

              const prev = prevShift[emp.id];
              let assigned = null;

              if (needs.M > 0 && !isShiftFlipViolation(prev, 'M')) assigned = 'M';
              else if (needs.A > 0 && !isShiftFlipViolation(prev, 'A')) assigned = 'A';

              if (assigned) {
                setShift(emp.id, d, assigned, sched, prevShift, streak);
                if (needs[assigned] > 0) needs[assigned]--;
                emp._workCredits--;
              }
            });

            // 4.4 Jokers fill N first (as designed)
            jokerList.forEach(emp => {
              if (isAssigned(emp.id, d, sched)) return;
              const prev = prevShift[emp.id];
              if (needs.N > 0 && !isShiftFlipViolation(prev, 'N')) {
                setShift(emp.id, d, 'N', sched, prevShift, streak);
                needs.N--;
              }
            });

            // 4.5 Rolling fills remaining N (if deficit)
            if (needs.N > 0) {
              rollingList.forEach(emp => {
                if (needs.N <= 0) return;
                if (isAssigned(emp.id, d, sched)) return;
                if (emp._workCredits <= 0) return;
                const prev = prevShift[emp.id];
                if (!isShiftFlipViolation(prev, 'N')) {
                  setShift(emp.id, d, 'N', sched, prevShift, streak);
                  needs.N--;
                  emp._workCredits--;
                }
              });
            }

            // 4.6 Desperate: Jokers cover remaining A/M
            if (needs.A > 0 || needs.M > 0) {
              jokerList.forEach(emp => {
                if (isAssigned(emp.id, d, sched)) return;
                const prev = prevShift[emp.id];
                let assigned = null;
                if (needs.A > 0 && !isShiftFlipViolation(prev, 'A')) assigned = 'A';
                else if (needs.M > 0 && !isShiftFlipViolation(prev, 'M')) assigned = 'M';
                if (assigned) {
                  setShift(emp.id, d, assigned, sched, prevShift, streak);
                  needs[assigned]--;
                }
              });
            }

            // 4.7 Anti-slack: Rolling still has credits â†’ must work (prefer N then A then M)
            rollingList.forEach(emp => {
              if (isAssigned(emp.id, d, sched)) return;
              if (emp._workCredits <= 0) {
                // not forced OFF day? still give OFF to keep calm
                setShift(emp.id, d, 'OFF', sched, prevShift, streak);
                return;
              }

              const prev = prevShift[emp.id];
              const order = ['N', 'A', 'M'];
              let assigned = null;

              for (const s of order) {
                if (!isShiftFlipViolation(prev, s)) { assigned = s; break; }
              }

              if (assigned) {
                setShift(emp.id, d, assigned, sched, prevShift, streak);
                // needs may go negative, fine (Ù‡Ø°Ø§ ÙÙ‚Ø· Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„)
                emp._workCredits--;
              } else {
                // if nothing safe, OFF
                setShift(emp.id, d, 'OFF', sched, prevShift, streak);
              }
            });

            // 4.8 Ensure any unassigned employee gets OFF
            [...rollingList, ...jokerList].forEach(emp => {
              if (!isAssigned(emp.id, d, sched)) {
                setShift(emp.id, d, 'OFF', sched, prevShift, streak);
              }
            });
          }
        });

        // Final pass: remove any flip violations by turning the offending day into OFF
        state.employees.forEach(emp => {
          let p = 'OFF';
          for (let d = 1; d <= numDays; d++) {
            const cell = sched[emp.id][d];
            if (!cell) continue;
            const s = cell.shift;
            if (isShiftFlipViolation(p, s)) {
              cell.shift = 'OFF';
              // streak breaks only on OFF anyway
              p = 'OFF';
            } else {
              p = s;
            }
          }
        });

        renderSchedule();
        saveData();
        showLoader(false);
        alert("âœ… ØªÙ… Ø§Ù„ØªÙˆØ²ÙŠØ¹ (V10.1) Ù…Ø¹ Ù…Ù†Ø¹ ØªØ¬Ù…Ù‘Ø¹ OFF Ù„Ù„Ø¯ÙˆÙ‘Ø§Ø±!");
      } catch (e) {
        console.error(e);
        showLoader(false);
        alert("Ø®Ø·Ø£: " + e.message);
      }
    }, 120);
  }

  // ==========================================
  // === OFF PLAN (Balanced per week) ===
  // ==========================================
  function buildBalancedOffPlan(employees, weeks, offPerWeekDefault) {
    // plan[weekIndex][empId] = [day, day]
    const plan = {};

    const key = getMonthKey();
    const sched = state.schedule[key] || {};

    const isVac = (empId, day) => {
      return sched[empId] && sched[empId][day] && sched[empId][day].shift === 'VAC';
    };

    weeks.forEach((w, wi) => {
      plan[wi] = {};
      const days = [];
      for (let d = w.start; d <= w.end; d++) days.push(d);

      const offCount = {};
      days.forEach(d => offCount[d] = 0);

      const emps = [...employees];
      shuffleInPlace(emps);

      emps.forEach(emp => {
        const offPerWeek = (emp.patternType === 'rolling')
          ? (Math.max(0, (emp.flexCounts?.OFF ?? offPerWeekDefault)))
          : offPerWeekDefault;

        plan[wi][emp.id] = [];

        for (let k = 0; k < offPerWeek; k++) {
          let candidates = days
            .filter(d => !plan[wi][emp.id].includes(d))
            .filter(d => !isVac(emp.id, d))
            .sort((a, b) => offCount[a] - offCount[b]);

          if (!candidates.length) break;

          // avoid adjacent OFF when possible
          if (plan[wi][emp.id].length === 1) {
            const prev = plan[wi][emp.id][0];
            const nonAdj = candidates.filter(d => Math.abs(d - prev) > 1);
            if (nonAdj.length) candidates = nonAdj;
          }

          // pick from top 3 least loaded
          const top = candidates.slice(0, Math.min(3, candidates.length));
          const pick = top[Math.floor(Math.random() * top.length)];

          plan[wi][emp.id].push(pick);
          offCount[pick] += 1;
        }
      });
    });

    return plan;
  }

  function shouldForceOff(empId, day, streak, offPlan, weekIndex) {
    if (streak[empId] >= MAX_CONSECUTIVE) return true;
    const arr = offPlan?.[weekIndex]?.[empId] || [];
    return arr.includes(day);
  }

  // ==========================================
  // === SCHED HELPERS ===
  // ==========================================
  function isAssigned(empId, day, sched) {
    return !!(sched[empId] && sched[empId][day]);
  }

  function setShift(empId, day, shift, sched, prevShift, streak) {
    sched[empId][day] = { shift, depot: "" };

    // update prev shift
    prevShift[empId] = shift;

    // update streak: only OFF breaks
    if (streakBreaks(shift)) streak[empId] = 0;
    else streak[empId] = (streak[empId] || 0) + 1;
  }

  function applyVacations(numDays, sched) {
    state.employees.forEach(emp => {
      if (!emp.vacationDates) return;
      emp.vacationDates
        .split(',')
        .map(x => parseInt(x.trim()))
        .filter(x => !isNaN(x) && x >= 1 && x <= numDays)
        .forEach(d => {
          sched[emp.id][d] = { shift: 'VAC', depot: '' };
        });
    });
  }

  function calculateDailyNeeds(numDays) {
    const needs = {};
    const depots = appConfig.depots.map(d => d.trim());
    const reqs = state.meta.requirements || {};

    for (let d = 1; d <= numDays; d++) {
      needs[d] = { M: 0, A: 0, N: 0 };
      depots.forEach(dep => {
        const r = reqs[dep] || {};
        needs[d].M += (r.M || 0);
        needs[d].A += (r.A || 0);
        needs[d].N += (r.N || 0);
      });
    }
    return needs;
  }

  function applyFixedEmployees(numDays, sched, dailyNeeds, streak, prevShift) {
    state.employees
      .filter(e => e.patternType === 'weekly')
      .forEach(emp => {
        for (let d = 1; d <= numDays; d++) {
          // if VAC already set, keep it
          if (sched[emp.id][d] && sched[emp.id][d].shift === 'VAC') {
            prevShift[emp.id] = 'VAC';
            // VAC Ù„Ø§ ÙŠÙƒØ³Ø± Ø§Ù„Ø³ØªØ±ÙŠÙƒ Ø­Ø³Ø¨ ÙƒÙ„Ø§Ù…Ùƒ
            streak[emp.id] = (streak[emp.id] || 0) + 1;
            continue;
          }

          const dayOfWeek = new Date(appConfig.year, appConfig.month - 1, d).getDay();
          let shift = emp.weeklyTemplate[dayOfWeek] || 'OFF';

          // safety gate
          if (isShiftFlipViolation(prevShift[emp.id], shift)) shift = 'OFF';

          // max consecutive (only breaks on OFF)
          if (streak[emp.id] >= MAX_CONSECUTIVE && shift !== 'OFF') shift = 'OFF';

          setShift(emp.id, d, shift, sched, prevShift, streak);

          // decrement needs if working
          if (dailyNeeds[d] && dailyNeeds[d][shift] > 0) dailyNeeds[d][shift]--;
        }
      });
  }

  // ==========================================
  // === WEEKS: Sunday -> Saturday (reset each Sunday) ===
  // ==========================================
  function buildWeeks(year, month, numDays) {
    const weeks = [];
    let d = 1;

    while (d <= numDays) {
      // find end of this week segment (until Saturday)
      const dow = new Date(year, month - 1, d).getDay(); // 0=Sun .. 6=Sat
      const daysToSat = 6 - dow;
      const end = Math.min(numDays, d + daysToSat);
      weeks.push({ start: d, end });
      d = end + 1;
    }
    return weeks;
  }

  // ==========================================
  // === DEPOT FILL (as you had) ===
  // ==========================================
  function fillDepots() {
    const key = getMonthKey();
    const sched = state.schedule[key];
    if (!sched || !confirm("ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ØŸ")) return;

    const numDays = daysInMonth(appConfig.year, appConfig.month);
    const reqs = state.meta.requirements || {};
    const depots = appConfig.depots.map(d => d.trim());

    // clear depot on work shifts
    for (let d = 1; d <= numDays; d++) {
      state.employees.forEach(e => {
        if (sched[e.id][d] && ['M','A','N'].includes(sched[e.id][d].shift)) {
          sched[e.id][d].depot = "";
        }
      });
    }

    for (let d = 1; d <= numDays; d++) {
      const counts = {};
      depots.forEach(dp => counts[dp] = { M:0, A:0, N:0 });

      const workers = { M:[], A:[], N:[] };
      state.employees.forEach(e => {
        const cell = sched[e.id][d];
        if (!cell) return;
        const s = cell.shift;
        if (['M','A','N'].includes(s)) workers[s].push(e);
      });

      ['M','A','N'].forEach(s => {
        const list = workers[s];

        // simple sort: higher quota first per first depot (kept as you had)
        const dep0 = depots[0];
        list.sort((a,b) => ((b.depotQuotas?.[dep0] || 0) - (a.depotQuotas?.[dep0] || 0)));

        // fill according to requirements
        depots.forEach(dep => {
          const need = (reqs[dep]?.[s] || 0);
          let i = 0;
          while (i < list.length && counts[dep][s] < need) {
            const e = list[i];
            if (!sched[e.id][d].depot) {
              sched[e.id][d].depot = dep;
              counts[dep][s]++;
            }
            i++;
          }
        });

        // assign leftovers to least-loaded depot for that shift
        list.forEach(e => {
          if (!sched[e.id][d].depot) {
            const target = depots.reduce((a,b) => counts[a][s] < counts[b][s] ? a : b);
            sched[e.id][d].depot = target;
            counts[target][s]++;
          }
        });
      });
    }

    renderSchedule();
    saveData();
  }

  // ==========================================
  // === RENDER: Schedule ===
  // ==========================================
  function renderSchedule() {
    const grid = document.getElementById('scheduleGrid');
    if (!grid) return;

    const numDays = daysInMonth(appConfig.year, appConfig.month);
    const data = state.schedule[getMonthKey()] || {};

    let html = `<thead><tr><th class="emp-col">Ø§Ù„Ù…ÙˆØ¸Ù</th>`;
    for (let d = 1; d <= numDays; d++) {
      const dow = new Date(appConfig.year, appConfig.month - 1, d).getDay();
      html += `<th>${d}<div style="font-size:.75rem; font-weight:900; color:#64748b; margin-top:2px;">${WEEKDAYS[dow]}</div></th>`;
    }
    html += `</tr></thead><tbody>`;

    state.employees.forEach(emp => {
      let row = `<tr><td class="emp-col">${emp.name}</td>`;
      let prev = 'OFF';

      for (let d = 1; d <= numDays; d++) {
        const c = (data[emp.id] && data[emp.id][d]) ? data[emp.id][d] : { shift: '' };
        const s = c.shift || '';
        const v = isShiftFlipViolation(prev, s) ? 'violation' : '';

        row += `<td class="cell shift-${s} ${v}">
          <div>${s || ''}</div>
          ${c.depot ? `<span class="depot-tag">${c.depot}</span>` : ``}
        </td>`;

        // prev shift tracking: keep same logic you used
        if (['M','A','N','VAC','X'].includes(s)) prev = s;
        else prev = 'OFF';
      }

      html += row + `</tr>`;
    });

    grid.innerHTML = html + `</tbody>`;
    analyzeCoverage();
  }

  function analyzeCoverage() {
    const report = document.getElementById('coverageReport');
    if (!report) return;

    const numDays = daysInMonth(appConfig.year, appConfig.month);
    const sched = state.schedule[getMonthKey()] || {};
    const depots = appConfig.depots.map(d => d.trim());
    const reqs = state.meta.requirements || {};
    const issues = [];

    for (let d = 1; d <= numDays; d++) {
      const counts = {};
      depots.forEach(dp => counts[dp] = { M:0, A:0, N:0 });

      state.employees.forEach(e => {
        const c = sched[e.id] && sched[e.id][d];
        if (c && c.depot && ['M','A','N'].includes(c.shift)) {
          const dep = c.depot.trim();
          if (counts[dep]) counts[dep][c.shift]++;
        }
      });

      depots.forEach(dep => {
        const r = reqs[dep] || {};
        ['M','A','N'].forEach(s => {
          const req = r[s] || 0;
          const act = counts[dep][s] || 0;
          if (act < req) issues.push(`ÙŠÙˆÙ… ${d} ${dep} (${s}): Ù…Ø·Ù„ÙˆØ¨ ${req}ØŒ Ù…ÙˆØ¬ÙˆØ¯ ${act}`);
        });
      });
    }

    report.innerHTML = issues.length
      ? issues.map(i => `<div class="report-item">${i}</div>`).join('')
      : `<div class="report-ok">âœ… Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù…Ù…ØªØ§Ø²!</div>`;
  }

  // ==========================================
  // === UTILS ===
  // ==========================================
  function getMonthKey() { return `${appConfig.year}-${appConfig.month}`; }
  function daysInMonth(y, m) { return new Date(y, m, 0).getDate(); }

  function clearMonth() {
    if (!confirm('Ù…Ø³Ø­ØŸ')) return;
    state.schedule[getMonthKey()] = {};
    renderSchedule();
    saveData();
  }

  function showLoader(show) {
    document.getElementById('loader').style.display = show ? 'flex' : 'none';
  }

  function exportCSV() {
    const numDays = daysInMonth(appConfig.year, appConfig.month);
    let csv = "\uFEFFEmployee,";
    for (let d = 1; d <= numDays; d++) csv += `${d},`;
    csv += "\n";

    const data = state.schedule[getMonthKey()] || {};
    state.employees.forEach(e => {
      csv += `"${e.name}",`;
      for (let d = 1; d <= numDays; d++) {
        const c = (data[e.id] && data[e.id][d]) || {};
        csv += `"${(c.shift||'')} ${(c.depot||'')}",`;
      }
      csv += "\n";
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'schedule.csv';
    a.click();
  }

  function shuffleInPlace(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
</script>

</body>
</html>
