<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© (V11 - Template Ø£Ø³Ø¨ÙˆØ¹ÙŠ + ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠ + Ø¹Ø±Ø¶ÙŠÙ†)</title>

  <style>
    :root{
      --bg:#f5f7fb;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --border:#e2e8f0;

      --primary:#2563eb;
      --primary2:#1d4ed8;

      --danger:#ef4444;
      --success:#10b981;
      --warning:#f59e0b;

      --chipM:#dbeafe;
      --chipMText:#1e40af;

      --chipA:#fef3c7;
      --chipAText:#92400e;

      --chipN:#111827;
      --chipNText:#f8fafc;

      --chipOFF:#dcfce7;
      --chipOFFText:#166534;

      --chipVAC:#f3e8ff;
      --chipVACText:#6b21a8;

      --chipX:#fee2e2;
      --chipXText:#991b1b;

      --shadow:0 10px 25px rgba(15,23,42,0.08);
      --radius:16px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Tahoma, Arial, "Noto Sans Arabic", "Noto Kufi Arabic", sans-serif;
      font-size:14px;
    }

    .app{
      max-width:1500px;
      margin:0 auto;
      padding:14px;
    }

    .topbar{
      background:linear-gradient(135deg,#ffffff, #f8fafc);
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:14px;
      box-shadow:var(--shadow);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      font-size:16px;
      margin-left:auto;
    }

    .brand .dot{
      width:12px;height:12px;border-radius:50%;
      background:radial-gradient(circle at 30% 30%, #60a5fa, #1d4ed8);
      box-shadow:0 0 0 4px rgba(37,99,235,0.12);
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    select, input{
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      outline:none;
      font-family:inherit;
    }

    .btn{
      padding:10px 14px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      cursor:pointer;
      font-weight:800;
      transition:all .15s ease;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 8px 18px rgba(15,23,42,0.08); }
    .btn.primary{ background:var(--primary); border-color:var(--primary); color:#fff; }
    .btn.primary:hover{ background:var(--primary2); }
    .btn.success{ background:var(--success); border-color:var(--success); color:#fff;}
    .btn.danger{ background:var(--danger); border-color:var(--danger); color:#fff;}
    .btn.ghost{ background:transparent; }

    .hint{
      width:100%;
      margin-top:10px;
      background:rgba(37,99,235,0.07);
      border:1px solid rgba(37,99,235,0.18);
      color:#1e40af;
      padding:10px 12px;
      border-radius:14px;
      font-weight:800;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .hint small{
      font-weight:700;
      color:#334155;
      opacity:.9;
    }

    .layout{
      margin-top:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .cardHead{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .seg{
      display:inline-flex;
      background:#f1f5f9;
      border:1px solid var(--border);
      border-radius:999px;
      padding:4px;
      gap:4px;
      align-items:center;
    }
    .seg button{
      border:none;
      background:transparent;
      padding:8px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      color:#64748b;
      transition:all .15s ease;
      font-family:inherit;
    }
    .seg button.active{
      background:#fff;
      color:#0f172a;
      box-shadow:0 6px 16px rgba(15,23,42,0.08);
    }

    .tableWrap{
      overflow:auto;
    }

    table{
      border-collapse:separate;
      border-spacing:0;
      width:100%;
      min-width:1200px;
    }

    thead th{
      position:sticky;
      top:0;
      z-index:10;
      background:#f8fafc;
      border-bottom:1px solid var(--border);
      font-weight:900;
      color:#0f172a;
      padding:10px 8px;
      text-align:center;
      white-space:nowrap;
    }

    th.empCol{
      position:sticky;
      right:0;
      z-index:12;
      background:#f8fafc;
      border-left:1px solid var(--border);
      text-align:right;
      padding-right:12px;
      min-width:180px;
    }

    tbody td{
      border-bottom:1px solid #f1f5f9;
      border-left:1px solid #f1f5f9;
      text-align:center;
      padding:6px 6px;
      height:62px;
      vertical-align:middle;
      background:#fff;
    }

    td.empCol{
      position:sticky;
      right:0;
      z-index:5;
      background:#fff;
      border-left:1px solid var(--border);
      text-align:right;
      padding-right:12px;
      font-weight:900;
      color:#0f172a;
      min-width:180px;
    }

    .chip{
      width:72px;
      margin:0 auto;
      border-radius:14px;
      padding:7px 8px 6px;
      font-weight:1000;
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      border:1px solid rgba(2,6,23,0.06);
      box-shadow: 0 8px 18px rgba(15,23,42,0.06);
    }
    .chip .s{ font-size:14px; letter-spacing:0.2px; }
    .chip .d{ font-size:11px; font-weight:900; opacity:.85; }

    .chip.M{ background:var(--chipM); color:var(--chipMText); }
    .chip.A{ background:var(--chipA); color:var(--chipAText); }
    .chip.N{ background:var(--chipN); color:var(--chipNText); }
    .chip.OFF{ background:var(--chipOFF); color:var(--chipOFFText); }
    .chip.VAC{ background:var(--chipVAC); color:var(--chipVACText); }
    .chip.X{ background:var(--chipX); color:var(--chipXText); }

    .chip.empty{
      width:72px;height:44px;
      background:#f8fafc;
      color:#94a3b8;
      border:1px dashed #cbd5e1;
      box-shadow:none;
      cursor:default;
    }

    .violationOutline{
      outline:3px solid var(--danger);
      outline-offset:2px;
    }

    /* Shift View */
    .shiftGrid{
      min-width:1200px;
    }
    .shiftRowLabel{
      position:sticky;
      right:0;
      background:#fff;
      z-index:6;
      border-left:1px solid var(--border);
      font-weight:1000;
      padding-right:12px;
      min-width:180px;
    }
    .shiftCell{
      padding:8px 8px;
      min-height:62px;
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      justify-content:center;
      align-items:center;
    }
    .namePill{
      padding:6px 8px;
      border-radius:999px;
      background:#f1f5f9;
      border:1px solid #e2e8f0;
      font-weight:900;
      font-size:12px;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .namePill .mini{
      font-size:11px;
      font-weight:1000;
      opacity:.8;
    }

    .panel{
      padding:14px;
    }

    .report{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .reportItem{
      background:#fff1f2;
      border:1px solid rgba(239,68,68,0.25);
      color:#9f1239;
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
    }
    .ok{
      background:#ecfdf5;
      border:1px solid rgba(16,185,129,0.25);
      color:#065f46;
      padding:12px 12px;
      border-radius:14px;
      font-weight:1000;
      text-align:center;
    }

    /* Modal */
    .modalBack{
      position:fixed;
      inset:0;
      background:rgba(2,6,23,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:14px;
    }
    .modal{
      width:min(520px, 100%);
      background:#fff;
      border-radius:18px;
      border:1px solid var(--border);
      box-shadow:0 30px 80px rgba(0,0,0,0.25);
      overflow:hidden;
    }
    .modalHead{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      font-weight:1000;
    }
    .modalBody{ padding:14px; display:grid; gap:10px; }
    .row2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .modalFoot{
      padding:12px 14px;
      border-top:1px solid var(--border);
      display:flex;
      gap:10px;
      justify-content:flex-start;
      flex-wrap:wrap;
    }
    .xBtn{
      border:none;
      background:#f1f5f9;
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px 10px;
      cursor:pointer;
      font-weight:1000;
    }

    .smallNote{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
      line-height:1.5;
    }
  </style>
</head>

<body>
<div class="app">

  <div class="topbar">
    <div class="brand">
      <span class="dot"></span>
      <span>ğŸ—“ï¸ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© â€” V11</span>
    </div>

    <div class="controls">
      <select id="selYear"></select>
      <select id="selMonth"></select>

      <button class="btn" onclick="loadData()">ğŸ”„ ØªØ­Ø¯ÙŠØ«</button>
      <button class="btn primary" onclick="saveData()">ğŸ’¾ Ø­ÙØ¸</button>

      <button class="btn primary" onclick="generateScheduleV11()">âš¡ ØªÙˆÙ„ÙŠØ¯ (V11)</button>
      <button class="btn success" onclick="fillDepots()">ğŸ­ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹</button>
      <button class="btn" onclick="exportCSV()">ğŸ“„ Excel</button>
      <button class="btn danger" onclick="clearMonth()">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
    </div>

    <div class="hint">
      <div>Template Ø£Ø³Ø¨ÙˆØ¹ÙŠ ÙŠØªÙƒØ±Ø± + Ù…Ù†Ø¹ ØªÙƒØ¯Ù‘Ø³ OFF Ù„Ù„Ø¯ÙˆÙ‘Ø§Ø± + Joker ÙŠÙØ¶Ù„ N + ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠ Ù…Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„</div>
      <small>Safety Gate: Nâ†’M/A Ù…Ù…Ù†ÙˆØ¹ | Aâ†’M Ù…Ù…Ù†ÙˆØ¹ | Max 6 Ù…ØªÙˆØ§ØµÙ„Ø© (OFF ÙÙ‚Ø· ÙŠÙƒØ³Ø±)</small>
    </div>
  </div>

  <div class="layout">

    <div class="card">
      <div class="cardHead">
        <div class="seg">
          <button id="btnViewEmp" class="active" onclick="setMainView('emp')">ğŸ‘¤ Ø­Ø³Ø¨ Ø§Ù„Ù…ÙˆØ¸Ù</button>
          <button id="btnViewShift" onclick="setMainView('shift')">ğŸ§© Ø­Ø³Ø¨ Ø§Ù„Ø´ÙØªØ§Øª</button>
        </div>

        <div style="margin-right:auto; color:#64748b; font-weight:900;">
          Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: <span id="lastUpdated">â€”</span>
        </div>
      </div>

      <div class="tableWrap" id="wrapEmpView">
        <table id="scheduleGrid"></table>
      </div>

      <div class="tableWrap" id="wrapShiftView" style="display:none">
        <table id="shiftGrid" class="shiftGrid"></table>
      </div>
    </div>

    <div class="card">
      <div class="cardHead">
        <strong>ğŸ“Œ ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØºØ·ÙŠØ© ÙˆØ§Ù„Ø£Ø®Ø·Ø§Ø¡</strong>
      </div>
      <div class="panel">
        <div id="coverageReport" class="report"></div>
      </div>
    </div>

  </div>
</div>

<!-- Modal for manual edit -->
<div class="modalBack" id="modalBack">
  <div class="modal">
    <div class="modalHead">
      <div id="modalTitle">ØªØ¹Ø¯ÙŠÙ„</div>
      <button class="xBtn" onclick="closeModal()">âœ•</button>
    </div>
    <div class="modalBody">
      <div class="row2">
        <div>
          <div class="smallNote">Ø§Ù„Ø´ÙØª</div>
          <select id="modalShift"></select>
        </div>
        <div>
          <div class="smallNote">Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Depot)</div>
          <select id="modalDepot"></select>
        </div>
      </div>
      <div class="smallNote">
        Ù…Ù„Ø§Ø­Ø¸Ø©: VAC override. ÙˆØ§Ù„Ø³ØªØ±ÙŠÙƒ ÙŠÙ†ÙƒØ³Ø± ÙÙ‚Ø· Ø¨Ù€ OFF.
      </div>
    </div>
    <div class="modalFoot">
      <button class="btn primary" onclick="applyManualEdit()">âœ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„</button>
      <button class="btn" onclick="closeModal()">Ø¥Ù„ØºØ§Ø¡</button>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG / STATE
========================= */
const API_URL = "https://script.google.com/macros/s/AKfycbz_Ax4qk6l7tmebex2kP9e2KCz4twS960mH5D2JxF8RIa0h_OeiAC96uTNSMunQrvha/exec";

const SHIFTS = ["M","A","N","OFF","VAC","X"];
const WEEKDAYS = ["Ø£Ø­Ø¯","Ø§Ø«Ù†ÙŠÙ†","Ø«Ù„Ø§Ø«Ø§Ø¡","Ø£Ø±Ø¨Ø¹Ø§Ø¡","Ø®Ù…ÙŠØ³","Ø¬Ù…Ø¹Ø©","Ø³Ø¨Øª"]; // JS getDay(): 0=Sun .. 6=Sat
const MAX_CONSECUTIVE = 6;

let state = {
  employees: [],
  schedule: {},   // schedule[yyyy-mm][empId][day] = {shift, depot}
  meta: {
    depots: ["Budaiya","IsaTown"],
    requirements: {}, // requirements[depot] = {M,A,N}
    updatedAt: null
  }
};

let appConfig = {
  year: new Date().getFullYear(),
  month: new Date().getMonth()+1
};

let uiMainView = "emp"; // emp | shift

// manual edit context
let editCtx = { empId:null, day:null };

/* =========================
   SAFETY GATE
========================= */
function isShiftFlipViolation(prev, next){
  if(!prev) return false;
  if(["OFF"].includes(prev)) return false; // only OFF resets; VAC/X are treated as "worked" for flips? (we keep flips check only for real shifts)
  if(["OFF","VAC","X"].includes(next)) return false;

  if(prev==="N" && (next==="M" || next==="A")) return true;
  if(prev==="A" && next==="M") return true;
  return false;
}

/* =========================
   INIT
========================= */
window.onload = () => {
  initDateSelectors();
  loadData();
};

function initDateSelectors(){
  const ySel = document.getElementById("selYear");
  const mSel = document.getElementById("selMonth");

  const currY = new Date().getFullYear();
  for(let y=currY-1; y<=currY+2; y++){
    ySel.add(new Option(y,y));
  }
  ySel.value = appConfig.year;

  const months = ["ÙŠÙ†Ø§ÙŠØ±","ÙØ¨Ø±Ø§ÙŠØ±","Ù…Ø§Ø±Ø³","Ø£Ø¨Ø±ÙŠÙ„","Ù…Ø§ÙŠÙˆ","ÙŠÙˆÙ†ÙŠÙˆ","ÙŠÙˆÙ„ÙŠÙˆ","Ø£ØºØ³Ø·Ø³","Ø³Ø¨ØªÙ…Ø¨Ø±","Ø£ÙƒØªÙˆØ¨Ø±","Ù†ÙˆÙÙ…Ø¨Ø±","Ø¯ÙŠØ³Ù…Ø¨Ø±"];
  months.forEach((m,i)=> mSel.add(new Option(m,i+1)));
  mSel.value = appConfig.month;

  ySel.onchange = () => { appConfig.year = +ySel.value; renderAll(); };
  mSel.onchange = () => { appConfig.month = +mSel.value; renderAll(); };
}

function setMainView(v){
  uiMainView = v;
  document.getElementById("btnViewEmp").classList.toggle("active", v==="emp");
  document.getElementById("btnViewShift").classList.toggle("active", v==="shift");
  document.getElementById("wrapEmpView").style.display = v==="emp" ? "" : "none";
  document.getElementById("wrapShiftView").style.display = v==="shift" ? "" : "none";
}

/* =========================
   API
========================= */
async function loadData(){
  try{
    const res = await fetch(`${API_URL}?action=load`);
    const json = await res.json();
    if(json.ok){
      const data = json.data || {};
      state.employees = data.employees || [];
      state.schedule = data.schedule || {};
      state.meta = data.meta || state.meta;

      if(state.meta.depots && state.meta.depots.length){
        state.meta.depots = state.meta.depots.map(x=>String(x).trim()).filter(Boolean);
      }else{
        state.meta.depots = ["Budaiya","IsaTown"];
      }

      // normalize employees
      state.employees.forEach(e=>{
        if(!e.id) e.id = "emp_"+Math.random().toString(36).slice(2,9);
        if(!e.name) e.name = "Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…";
        if(!e.patternType) e.patternType = "weekly"; // weekly | rolling | joker
        if(!e.weeklyTemplate) e.weeklyTemplate = Array(7).fill("OFF");
        if(!e.flexCounts) e.flexCounts = {M:1,A:2,N:2,OFF:2};
        if(!e.depotQuotas) e.depotQuotas = {};
        if(e.vacationDates == null) e.vacationDates = "";
        if(!e.rollingTemplate) e.rollingTemplate = null; // generated weekly template for rolling (7)
      });

      document.getElementById("lastUpdated").textContent =
        state.meta.updatedAt ? new Date(state.meta.updatedAt).toLocaleString() : "â€”";

      renderAll();
    }
  }catch(err){
    console.error(err);
    alert("ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±.");
  }
}

async function saveData(){
  try{
    state.meta.updatedAt = new Date().toISOString();
    await fetch(API_URL,{
      method:"POST",
      body: JSON.stringify({
        action:"save",
        payload:{
          employees: state.employees,
          schedule: state.schedule,
          meta: state.meta
        }
      })
    });
    document.getElementById("lastUpdated").textContent = new Date().toLocaleString();
  }catch(err){
    console.error(err);
    alert("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸.");
  }
}

/* =========================
   DATE HELPERS
========================= */
function getMonthKey(){
  return `${appConfig.year}-${String(appConfig.month).padStart(2,"0")}`;
}
function daysInMonth(y,m){
  return new Date(y,m,0).getDate();
}
function dayOfWeek(y,m,day){ // 0..6
  return new Date(y,m-1,day).getDay();
}

/* =========================
   REQUIREMENTS / NEEDS
========================= */
function calcDailyNeeds(numDays){
  const depots = state.meta.depots;
  const reqs = state.meta.requirements || {};
  const needs = {};
  for(let d=1; d<=numDays; d++){
    needs[d] = {M:0,A:0,N:0};
    depots.forEach(dep=>{
      const r = reqs[dep] || {M:0,A:0,N:0};
      needs[d].M += (+r.M||0);
      needs[d].A += (+r.A||0);
      needs[d].N += (+r.N||0);
    });
  }
  return needs;
}

/* =========================
   VACATIONS
========================= */
function applyVacations(numDays, sched){
  state.employees.forEach(emp=>{
    const list = String(emp.vacationDates||"")
      .split(",")
      .map(x=>parseInt(x.trim(),10))
      .filter(x=>!isNaN(x) && x>=1 && x<=numDays);

    list.forEach(d=>{
      sched[emp.id][d] = {shift:"VAC", depot:""};
    });
  });
}

/* =========================
   V11 GENERATOR
   - weekly template repeat
   - rolling: choose OFF weekdays balanced (avoid Fri)
   - fill needs with upgrade preference
   - joker prefer N
========================= */
function generateScheduleV11(){
  if(!confirm("ØªØ£ÙƒÙŠØ¯ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙˆÙ„ (V11)ØŸ\n\n- Rolling: Template Ø£Ø³Ø¨ÙˆØ¹ÙŠ ÙŠØªÙƒØ±Ø±\n- Ù…Ù†Ø¹ ØªÙƒØ¯Ù‘Ø³ OFF\n- Joker ÙŠÙØ¶Ù„ N\n- Safety Gate Ù…Ø·Ø¨Ù‘Ù‚")) return;

  const key = getMonthKey();
  const numDays = daysInMonth(appConfig.year, appConfig.month);
  if(!state.schedule[key]) state.schedule[key] = {};
  const sched = state.schedule[key];

  // ensure emp rows
  state.employees.forEach(e=>{
    if(!sched[e.id]) sched[e.id] = {};
  });

  // clear only non-VAC? (we regenerate all month; VAC stays)
  for(const emp of state.employees){
    for(let d=1; d<=numDays; d++){
      sched[emp.id][d] = null;
    }
  }
  // apply VAC first (override)
  applyVacations(numDays, sched);

  const needs = calcDailyNeeds(numDays);

  // split employees
  const fixed = state.employees.filter(e=>e.patternType==="weekly");
  const rolling = state.employees.filter(e=>e.patternType==="rolling");
  const jokers = state.employees.filter(e=>e.patternType==="joker");

  // global off caps for rolling (avoid clustering)
  const rollingCount = rolling.length;
  const maxRollingOffPerDay = Math.max(1, Math.floor(rollingCount/2)); // 4 -> 2
  const fridayRollingOffCap = Math.min(1, maxRollingOffPerDay); // strongly avoid Fri

  // 1) Apply FIXED across month (repeat weeklyTemplate)
  // track prevShift + streak (OFF only resets streak)
  const prevShift = {};
  const streak = {};
  state.employees.forEach(e=>{ prevShift[e.id]="OFF"; streak[e.id]=0; });

  for(const emp of fixed){
    for(let d=1; d<=numDays; d++){
      if(sched[emp.id][d]?.shift === "VAC") {
        // VAC override (doesn't reset streak)
        prevShift[emp.id] = "VAC";
        streak[emp.id] += 1;
        continue;
      }

      const wd = dayOfWeek(appConfig.year, appConfig.month, d);
      let s = emp.weeklyTemplate[wd] || "OFF";

      // streak rule: only OFF resets. If already 6 and today not OFF => force OFF (unless VAC)
      if(streak[emp.id] >= MAX_CONSECUTIVE && s !== "OFF") s = "OFF";

      // flip rule for real shifts
      if(isShiftFlipViolation(prevShift[emp.id], s)) s = "OFF";

      sched[emp.id][d] = {shift:s, depot:""};

      // update needs for real working shifts
      if(["M","A","N"].includes(s) && needs[d][s] > 0) needs[d][s]--;

      // update streak / prev
      prevShift[emp.id] = s;
      if(s === "OFF") streak[emp.id]=0; else streak[emp.id]+=1;
    }
  }

  // 2) Build WEEKLY TEMPLATE for ROLLING (7 days) with balanced OFF weekdays
  // We will:
  // - choose OFF weekdays (count=flexCounts.OFF) avoiding Friday
  // - distribute OFF weekdays among rolling using global load per weekday and per-day cap heuristics
  // - choose remaining shifts based on flexCounts with upgrade preference later during day assignment
  // For stability, store emp.rollingTemplate = [{shiftForWeekday}] length 7
  const offLoadWeekday = Array(7).fill(0); // how many rolling OFF on each weekday
  // seed offLoad from existing fixed OFF? (not needed; only for rolling balancing)

  // helper to see if a weekday is "Friday"
  const FRIDAY = 5;

  // pick OFF weekdays per rolling employee
  for(const emp of rolling){
    const offNeeded = Math.max(0, +((emp.flexCounts||{}).OFF||2));
    // candidate weekdays: prefer not Friday, and spread
    const cands = [0,1,2,3,4,6,5]; // put Friday last
    const chosen = [];

    for(let k=0; k<offNeeded; k++){
      let best = null;
      let bestScore = Infinity;
      for(const wd of cands){
        if(chosen.includes(wd)) continue;

        // scoring: avoid friday heavily
        let score = offLoadWeekday[wd] * 10;
        if(wd === FRIDAY) score += 1000;

        // avoid adjacent clustering (e.g. Thu+Fri or Fri+Sat)
        if(chosen.some(x=> Math.abs(x-wd)===1)) score += 25;

        // soft prefer mid-week for rolling OFF if fixed staff off is Friday (your rule)
        // (we don't have fixedOffLoad here; keep simple)

        if(score < bestScore){
          bestScore = score;
          best = wd;
        }
      }
      if(best==null) break;
      chosen.push(best);
      offLoadWeekday[best] += 1;
    }

    emp._rollingOffWeekdays = chosen.slice(); // store
  }

  // 3) Assign Rolling templates (weekday->shift) using their bucket, with OFF fixed first.
  // Remaining weekdays get M/A/N pattern counts (best-effort). We don't "downgrade" here; we keep counts.
  for(const emp of rolling){
    const f = emp.flexCounts || {M:1,A:2,N:2,OFF:2};
    let left = { M:+f.M||0, A:+f.A||0, N:+f.N||0 };
    const tmpl = Array(7).fill("OFF");

    // apply OFF weekdays
    for(const wd of (emp._rollingOffWeekdays||[])){
      tmpl[wd] = "OFF";
    }

    // fill remaining weekdays with N then A then M by default (since later we can upgrade to M if needed)
    // This default reduces Anti-Flip issues with next-day M.
    const fillOrder = ["N","A","M"];
    for(let wd=0; wd<7; wd++){
      if(tmpl[wd] === "OFF") continue;
      let chosen = null;
      for(const s of fillOrder){
        if(left[s] > 0){
          chosen = s;
          left[s]--;
          break;
        }
      }
      if(!chosen){
        // if no remaining, fallback OFF (shouldn't happen if counts are consistent)
        chosen = "OFF";
      }
      tmpl[wd] = chosen;
    }

    emp.rollingTemplate = tmpl;
  }

  // 4) Apply ROLLING day-by-day:
  // - Use weekly template
  // - But adjust by needs with Upgrade preference:
  //   - If template is N/A and needs M, allow upgrade to M (if safe)
  //   - If template is N and needs A, upgrade to A
  //   - Avoid downgrade unless needed to fill N deficit (rare)
  // - Enforce rolling OFF anti-cluster per actual calendar day:
  //   We'll keep rollingOffCountPerDay[d] and if cap exceeded, we try to swap OFF to a working shift (safe) and move OFF to another weekday later (but stable template).
  //   Since you want template stable, we solve clustering by template weekday balancing primarily.
  const rollingOffCountPerDay = Array(numDays+1).fill(0);

  // first pass: assign as template (with safety/streak)
  for(const emp of rolling){
    for(let d=1; d<=numDays; d++){
      if(sched[emp.id][d]?.shift === "VAC") {
        prevShift[emp.id] = "VAC";
        streak[emp.id] += 1;
        continue;
      }

      const wd = dayOfWeek(appConfig.year, appConfig.month, d);
      let base = (emp.rollingTemplate && emp.rollingTemplate[wd]) ? emp.rollingTemplate[wd] : "OFF";

      // avoid Friday OFF strongly (if still happened)
      if(base==="OFF" && wd===FRIDAY){
        // try convert to A or N if safe; keep OFF for another day is hard without breaking template
        // We'll attempt only if this day would cause shortage or cap exceeded later
        // keep base OFF for now; clustering handled by template generator
      }

      // streak rule (OFF only resets)
      if(streak[emp.id] >= MAX_CONSECUTIVE && base !== "OFF") base = "OFF";
      if(isShiftFlipViolation(prevShift[emp.id], base)) base = "OFF";

      sched[emp.id][d] = {shift:base, depot:""};

      if(base==="OFF") rollingOffCountPerDay[d]++;

      // update needs if working
      if(["M","A","N"].includes(base) && needs[d][base] > 0) needs[d][base]--;

      prevShift[emp.id] = base;
      if(base==="OFF") streak[emp.id]=0; else streak[emp.id]+=1;
    }
  }

  // 5) Improve coverage by upgrading rolling shifts (keep template stable, but allow upgrades)
  // For each day, if needs.M>0 or needs.A>0 or needs.N>0, we try adjust rolling (not fixed) where safe.
  for(let d=1; d<=numDays; d++){
    const wd = dayOfWeek(appConfig.year, appConfig.month, d);

    // build candidate list of rolling employees working that day (not VAC)
    const candidates = rolling
      .filter(emp => {
        const c = sched[emp.id][d];
        if(!c) return false;
        if(c.shift==="VAC") return false;
        return true;
      });

    // helper to get previous day shift (actual)
    function getPrev(empId){
      if(d===1) return "OFF";
      const c = sched[empId][d-1];
      return c?.shift || "OFF";
    }

    // Upgrade M
    if(needs[d].M > 0){
      // prefer upgrade A->M, then N->M (if safe and not violating)
      const pool = candidates
        .filter(emp=>{
          const s = sched[emp.id][d].shift;
          if(!["A","N"].includes(s)) return false;
          if(isShiftFlipViolation(getPrev(emp.id), "M")) return false;
          // keep streak rule
          // if already 6 streak and today would be work => can't (but if today already work A/N, upgrading doesn't change streak)
          return true;
        });

      // sort prefer A first (upgrade) then N, and also avoid downgrades
      pool.sort((a,b)=>{
        const sa = sched[a.id][d].shift;
        const sb = sched[b.id][d].shift;
        const wa = (sa==="A") ? 0 : 1;
        const wb = (sb==="A") ? 0 : 1;
        return wa-wb;
      });

      for(const emp of pool){
        if(needs[d].M <= 0) break;
        // apply upgrade
        sched[emp.id][d].shift = "M";
        needs[d].M--;
      }
    }

    // Upgrade A (N->A)
    if(needs[d].A > 0){
      const pool = candidates
        .filter(emp=>{
          const s = sched[emp.id][d].shift;
          if(s!=="N") return false;
          if(isShiftFlipViolation(getPrev(emp.id), "A")) return false;
          return true;
        });
      for(const emp of pool){
        if(needs[d].A <= 0) break;
        sched[emp.id][d].shift = "A";
        needs[d].A--;
      }
    }

    // Fill N deficits with rolling (avoid downgrades; use M/A only if needed)
    if(needs[d].N > 0){
      // first: those already A or M can move to N (downgrade) only if required
      const pool = candidates
        .filter(emp=>{
          const s = sched[emp.id][d].shift;
          if(!["A","M"].includes(s)) return false;
          if(isShiftFlipViolation(getPrev(emp.id), "N")) return false;
          return true;
        });
      for(const emp of pool){
        if(needs[d].N <= 0) break;
        sched[emp.id][d].shift = "N";
        needs[d].N--;
      }
    }

    // Enforce rolling OFF cap per day (post-adjust):
    // If too many rolling OFF in day, convert some OFF into A/N (prefer N), especially if day has deficits.
    if(rollingOffCountPerDay[d] > maxRollingOffPerDay || (wd===FRIDAY && rollingOffCountPerDay[d] > fridayRollingOffCap)){
      const cap = (wd===FRIDAY) ? fridayRollingOffCap : maxRollingOffPerDay;
      const excess = rollingOffCountPerDay[d] - cap;

      if(excess > 0){
        const offPool = rolling.filter(emp=>{
          const c = sched[emp.id][d];
          if(!c) return false;
          if(c.shift!=="OFF") return false;
          if(c.shift==="VAC") return false;
          // respect streak? converting OFF to work will increase streak; ensure not >6
          // streak computed with OFF reset; so if we convert, streak becomes previous streak+1
          // We approximate: check back streak by scanning previous days until OFF
          const s = computeStreakIfWork(emp.id, d);
          return s <= MAX_CONSECUTIVE; // allow
        });

        // sort by who has easiest safe shift
        offPool.sort((a,b)=>{
          return (a.id > b.id) ? 1 : -1;
        });

        let changed = 0;
        for(const emp of offPool){
          if(changed >= excess) break;

          const p = getPrev(emp.id);
          // prefer N then A then M (and only if not violating)
          let pick = null;
          if(needs[d].N > 0 && !isShiftFlipViolation(p,"N")) pick="N";
          else if(needs[d].A > 0 && !isShiftFlipViolation(p,"A")) pick="A";
          else if(needs[d].M > 0 && !isShiftFlipViolation(p,"M")) pick="M";
          else{
            // still convert to N if safe (joker should cover but we help)
            if(!isShiftFlipViolation(p,"N")) pick="N";
            else if(!isShiftFlipViolation(p,"A")) pick="A";
            else if(!isShiftFlipViolation(p,"M")) pick="M";
          }

          if(pick){
            sched[emp.id][d].shift = pick;
            rollingOffCountPerDay[d]--;
            if(needs[d][pick] > 0) needs[d][pick]--;
            changed++;
          }
        }
      }
    }
  }

  // 6) Apply JOKER last (prefer N only)
  for(const emp of jokers){
    for(let d=1; d<=numDays; d++){
      if(sched[emp.id][d]?.shift === "VAC") {
        prevShift[emp.id] = "VAC";
        streak[emp.id] += 1;
        continue;
      }

      // if already assigned (shouldn't)
      if(sched[emp.id][d] && sched[emp.id][d].shift) continue;

      const p = (d===1) ? "OFF" : (sched[emp.id][d-1]?.shift || "OFF");
      const wd = dayOfWeek(appConfig.year, appConfig.month, d);

      // avoid Friday OFF for joker as well (prefer work nights on Fri)
      // Joker works 6 days, 1 OFF per week:
      // we pick OFF day = weekday with lowest deficits of N and not Friday.
      // simple: Saturday default OFF (wd=6) unless conflicts.
      let offDay = 6; // Sat
      if(wd === offDay){
        sched[emp.id][d] = {shift:"OFF", depot:""};
        prevShift[emp.id] = "OFF";
        streak[emp.id]=0;
        continue;
      }

      // if streak exceeded, force OFF (only rule)
      if(streak[emp.id] >= MAX_CONSECUTIVE){
        sched[emp.id][d] = {shift:"OFF", depot:""};
        prevShift[emp.id] = "OFF";
        streak[emp.id]=0;
        continue;
      }

      // pick shift
      let s = "N";
      if(needs[d].N > 0 && !isShiftFlipViolation(p,"N")){
        s="N";
        needs[d].N--;
      }else{
        // do NOT give day unless deficit
        if(needs[d].A > 0 && !isShiftFlipViolation(p,"A")){
          s="A";
          needs[d].A--;
        }else if(needs[d].M > 0 && !isShiftFlipViolation(p,"M")){
          s="M";
          needs[d].M--;
        }else{
          // still prefer N
          if(isShiftFlipViolation(p,"N")){
            // try A then M if N illegal
            if(!isShiftFlipViolation(p,"A")) s="A";
            else if(!isShiftFlipViolation(p,"M")) s="M";
            else s="OFF";
          }
        }
      }

      // streak rule if s is work (OFF resets)
      if(streak[emp.id] >= MAX_CONSECUTIVE && s !== "OFF") s="OFF";

      sched[emp.id][d] = {shift:s, depot:""};
      prevShift[emp.id]=s;
      if(s==="OFF") streak[emp.id]=0; else streak[emp.id]+=1;
    }
  }

  // 7) Final pass: enforce flip rule strictly (convert violating shift to OFF)
  for(const emp of state.employees){
    let p = "OFF";
    for(let d=1; d<=numDays; d++){
      const c = sched[emp.id][d];
      if(!c) continue;
      const s = c.shift || "OFF";

      if(s==="VAC"){
        p="VAC";
        continue;
      }

      if(isShiftFlipViolation(p, s)){
        // keep VAC override only; otherwise OFF
        c.shift = "OFF";
      }
      p = c.shift;
    }
  }

  // ensure empty cells become OFF (except VAC)
  for(const emp of state.employees){
    for(let d=1; d<=numDays; d++){
      if(!sched[emp.id][d]) sched[emp.id][d] = {shift:"OFF", depot:""};
      if(!sched[emp.id][d].shift) sched[emp.id][d].shift = "OFF";
      if(sched[emp.id][d].shift!=="OFF" && sched[emp.id][d].shift!=="VAC" && !["M","A","N","X"].includes(sched[emp.id][d].shift)){
        sched[emp.id][d].shift = "OFF";
      }
    }
  }

  renderAll();
  saveData();
  alert("âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙˆÙ„ (V11). ØªÙ‚Ø¯Ø± ØªØ¹Ø¯Ù‘Ù„ ÙŠØ¯ÙˆÙŠÙ‹Ø§ Ù…Ù† Ø§Ù„Ø®Ù„Ø§ÙŠØ§.");
}

// compute current streak if we convert OFF to a working shift (OFF only resets)
function computeStreakIfWork(empId, day){
  // count backwards until OFF or start
  let cnt = 0;
  for(let d=day-1; d>=1; d--){
    const s = state.schedule[getMonthKey()]?.[empId]?.[d]?.shift || "OFF";
    if(s==="OFF") break;
    cnt++;
  }
  // if we convert today to work, streak becomes cnt+1
  return cnt+1;
}

/* =========================
   DEPOT FILL (kept simple, but stable)
========================= */
function fillDepots(){
  const key = getMonthKey();
  const sched = state.schedule[key];
  if(!sched) return alert("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¬Ø¯ÙˆÙ„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±.");

  const numDays = daysInMonth(appConfig.year, appConfig.month);
  const depots = state.meta.depots;
  const reqs = state.meta.requirements || {};

  // clear depots for working shifts
  for(const emp of state.employees){
    for(let d=1; d<=numDays; d++){
      const c = sched[emp.id][d];
      if(c && ["M","A","N"].includes(c.shift)) c.depot = "";
      if(c && !["M","A","N"].includes(c.shift)) c.depot = "";
    }
  }

  // assign depots per day/shift based on requirements, then balance
  for(let d=1; d<=numDays; d++){
    const counts = {};
    depots.forEach(dep=> counts[dep] = {M:0,A:0,N:0});

    const workers = {M:[],A:[],N:[]};
    for(const emp of state.employees){
      const c = sched[emp.id][d];
      if(!c) continue;
      if(["M","A","N"].includes(c.shift)){
        workers[c.shift].push(emp);
      }
    }

    for(const s of ["M","A","N"]){
      // sort by who "needs" depot quota less-used (simple: prefer higher quota value)
      const list = workers[s].slice().sort((a,b)=>{
        const qa = (a.depotQuotas && depots.reduce((sum,dep)=>sum+(+a.depotQuotas[dep]||0),0)) || 0;
        const qb = (b.depotQuotas && depots.reduce((sum,dep)=>sum+(+b.depotQuotas[dep]||0),0)) || 0;
        return qb-qa;
      });

      // fill required
      for(const dep of depots){
        const need = (+((reqs[dep]||{})[s])||0);
        while(counts[dep][s] < need && list.length){
          const emp = list.shift();
          if(!sched[emp.id][d].depot){
            sched[emp.id][d].depot = dep;
            counts[dep][s]++;
          }
        }
      }

      // leftover: distribute to least filled
      while(list.length){
        const emp = list.shift();
        const target = depots.reduce((best,dep)=>{
          if(best==null) return dep;
          return (counts[dep][s] < counts[best][s]) ? dep : best;
        }, null);
        sched[emp.id][d].depot = target;
        counts[target][s]++;
      }
    }
  }

  renderAll();
  saveData();
}

/* =========================
   RENDER (EMP VIEW)
========================= */
function renderAll(){
  renderSchedule();
  renderShiftView();
  analyzeCoverage();
}

function renderSchedule(){
  const grid = document.getElementById("scheduleGrid");
  const numDays = daysInMonth(appConfig.year, appConfig.month);
  const data = state.schedule[getMonthKey()] || {};

  let html = `<thead><tr><th class="empCol">Ø§Ù„Ù…ÙˆØ¸Ù</th>`;
  for(let d=1; d<=numDays; d++){
    const wd = dayOfWeek(appConfig.year, appConfig.month, d);
    html += `<th>${d}<div style="font-size:11px;color:#64748b;font-weight:1000;margin-top:4px">${WEEKDAYS[wd]}</div></th>`;
  }
  html += `</tr></thead><tbody>`;

  for(const emp of state.employees){
    html += `<tr><td class="empCol">${escapeHtml(emp.name)}</td>`;
    let prev = "OFF";
    for(let d=1; d<=numDays; d++){
      const c = (data[emp.id] && data[emp.id][d]) ? data[emp.id][d] : {shift:"OFF", depot:""};
      const s = c.shift || "OFF";
      const depot = c.depot || "";

      const viol = isShiftFlipViolation(prev, s);
      const outline = viol ? "violationOutline" : "";

      const chip = renderChip(s, depot, emp.id, d, outline);

      html += `<td>${chip}</td>`;

      // prev for flip uses actual shift (VAC/X count as previous, but next-day flip allowed since next excludes VAC/X)
      prev = s || "OFF";
    }
    html += `</tr>`;
  }

  html += `</tbody>`;
  grid.innerHTML = html;
}

function renderChip(shift, depot, empId, day, extraClass=""){
  if(!shift) shift="OFF";
  const isEmpty = (shift==="");
  if(isEmpty){
    return `<div class="chip empty">â€”</div>`;
  }
  const depText = depot ? escapeHtml(depot) : "â€”";
  const click = `openEdit('${empId}',${day})`;
  return `
    <div class="chip ${shift} ${extraClass}" onclick="${click}">
      <div class="s">${shift}</div>
      <div class="d">${depText}</div>
    </div>
  `;
}

/* =========================
   RENDER (SHIFT VIEW)
   Rows = shifts (M,A,N,OFF,VAC,X)
   Cols = days
========================= */
function renderShiftView(){
  const grid = document.getElementById("shiftGrid");
  const numDays = daysInMonth(appConfig.year, appConfig.month);
  const data = state.schedule[getMonthKey()] || {};

  let html = `<thead><tr><th class="empCol">Ø§Ù„Ø´ÙØª</th>`;
  for(let d=1; d<=numDays; d++){
    const wd = dayOfWeek(appConfig.year, appConfig.month, d);
    html += `<th>${d}<div style="font-size:11px;color:#64748b;font-weight:1000;margin-top:4px">${WEEKDAYS[wd]}</div></th>`;
  }
  html += `</tr></thead><tbody>`;

  for(const s of SHIFTS){
    html += `<tr><td class="shiftRowLabel">${s}</td>`;
    for(let d=1; d<=numDays; d++){
      const pills = [];
      for(const emp of state.employees){
        const c = data[emp.id]?.[d];
        if(!c) continue;
        if((c.shift||"OFF") === s){
          const dep = c.depot ? ` <span class="mini">(${escapeHtml(c.depot)})</span>` : "";
          pills.push(`<span class="namePill">${escapeHtml(emp.name)}${dep}</span>`);
        }
      }
      html += `<td><div class="shiftCell">${pills.join("") || "â€”"}</div></td>`;
    }
    html += `</tr>`;
  }

  html += `</tbody>`;
  grid.innerHTML = html;
}

/* =========================
   COVERAGE ANALYSIS
========================= */
function analyzeCoverage(){
  const report = document.getElementById("coverageReport");
  const numDays = daysInMonth(appConfig.year, appConfig.month);
  const sched = state.schedule[getMonthKey()] || {};
  const depots = state.meta.depots;
  const reqs = state.meta.requirements || {};

  const issues = [];

  for(let d=1; d<=numDays; d++){
    const counts = {};
    depots.forEach(dep=> counts[dep] = {M:0,A:0,N:0});

    for(const emp of state.employees){
      const c = sched[emp.id]?.[d];
      if(!c) continue;
      if(["M","A","N"].includes(c.shift) && c.depot){
        if(counts[c.depot]) counts[c.depot][c.shift]++;
      }
    }

    for(const dep of depots){
      const r = reqs[dep] || {M:0,A:0,N:0};
      for(const s of ["M","A","N"]){
        const need = +r[s]||0;
        const got = counts[dep][s]||0;
        if(got < need){
          issues.push(`ÙŠÙˆÙ… ${d} | ${dep} | (${s}) : Ù…Ø·Ù„ÙˆØ¨ ${need} ØŒ Ù…ÙˆØ¬ÙˆØ¯ ${got}`);
        }
      }
    }
  }

  // add flip violations summary
  for(const emp of state.employees){
    let p="OFF";
    for(let d=1; d<=numDays; d++){
      const c = sched[emp.id]?.[d];
      if(!c) continue;
      const s = c.shift || "OFF";
      if(isShiftFlipViolation(p, s)){
        issues.push(`Ù…Ø®Ø§Ù„ÙØ© Flip: ${emp.name} ÙŠÙˆÙ… ${d} (${p} â†’ ${s})`);
      }
      p=s;
    }
  }

  report.innerHTML = issues.length
    ? issues.map(x=>`<div class="reportItem">${escapeHtml(x)}</div>`).join("")
    : `<div class="ok">âœ… Ø§Ù„ØªØºØ·ÙŠØ© Ù…Ù…ØªØ§Ø²Ø© ÙˆÙ„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø®Ø§Ù„ÙØ§Øª Ø¸Ø§Ù‡Ø±Ø©.</div>`;
}

/* =========================
   MANUAL EDIT (Modal)
========================= */
function openEdit(empId, day){
  editCtx.empId = empId;
  editCtx.day = day;

  const key = getMonthKey();
  const c = state.schedule[key]?.[empId]?.[day] || {shift:"OFF", depot:""};

  document.getElementById("modalTitle").textContent =
    `ØªØ¹Ø¯ÙŠÙ„: ${getEmpName(empId)} â€” ÙŠÙˆÙ… ${day}`;

  // shifts
  const selShift = document.getElementById("modalShift");
  selShift.innerHTML = SHIFTS.map(s=> `<option value="${s}">${s}</option>`).join("");
  selShift.value = c.shift || "OFF";

  // depots
  const selDepot = document.getElementById("modalDepot");
  const depots = state.meta.depots || [];
  selDepot.innerHTML = `<option value="">â€”</option>` + depots.map(d=> `<option value="${escapeHtml(d)}">${escapeHtml(d)}</option>`).join("");
  selDepot.value = c.depot || "";

  document.getElementById("modalBack").style.display="flex";
}

function closeModal(){
  document.getElementById("modalBack").style.display="none";
}

function applyManualEdit(){
  const key = getMonthKey();
  const {empId, day} = editCtx;
  if(!empId || !day) return closeModal();

  if(!state.schedule[key]) state.schedule[key] = {};
  if(!state.schedule[key][empId]) state.schedule[key][empId] = {};

  const newShift = document.getElementById("modalShift").value;
  const newDepot = document.getElementById("modalDepot").value;

  state.schedule[key][empId][day] = {
    shift: newShift,
    depot: (["M","A","N"].includes(newShift) ? newDepot : "")
  };

  closeModal();
  renderAll();
  saveData();
}

/* =========================
   EXPORT / CLEAR
========================= */
function exportCSV(){
  const numDays = daysInMonth(appConfig.year, appConfig.month);
  const data = state.schedule[getMonthKey()] || {};

  let csv = "\uFEFFØ§Ù„Ù…ÙˆØ¸Ù,";
  for(let d=1; d<=numDays; d++) csv += `${d},`;
  csv += "\n";

  for(const emp of state.employees){
    csv += `"${String(emp.name).replaceAll('"','""')}",`;
    for(let d=1; d<=numDays; d++){
      const c = data[emp.id]?.[d] || {shift:"", depot:""};
      csv += `"${(c.shift||"")}${c.depot?(" "+c.depot):""}",`;
    }
    csv += "\n";
  }

  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download=`schedule_${getMonthKey()}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

function clearMonth(){
  if(!confirm("Ù…Ø³Ø­ Ø¬Ø¯ÙˆÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±ØŸ")) return;
  state.schedule[getMonthKey()] = {};
  renderAll();
  saveData();
}

/* =========================
   UTIL
========================= */
function getEmpName(id){
  const e = state.employees.find(x=>x.id===id);
  return e ? e.name : id;
}
function escapeHtml(str){
  return String(str ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
</script>
</body>
</html>
