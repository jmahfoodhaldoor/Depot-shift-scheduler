<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shift Scheduling SPA (Safety-Gated Tiered Scheduler)</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#0f1b33; --panel2:#0c162b; --text:#e7eefc; --muted:#9ab0d0;
      --border:#1f335d; --primary:#4f8cff; --good:#22c55e; --warn:#f59e0b; --bad:#ef4444;
      --chip:#132550;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;color:var(--text);background:linear-gradient(180deg,var(--bg),#070d18)}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--border);position:sticky;top:0;background:rgba(11,18,32,.92);backdrop-filter:blur(10px);z-index:50}
    header .left{display:flex;gap:10px;align-items:center}
    h1{font-size:15px;margin:0;font-weight:800;letter-spacing:.2px}
    .toolbar{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    select,input,button,textarea{font:inherit}
    select,input{background:var(--panel);border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:10px}
    button{background:var(--panel);border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:10px;font-weight:700;cursor:pointer}
    button:hover{border-color:#2b4a85;transform:translateY(-1px)}
    button.primary{background:linear-gradient(180deg,#3d7cff,#2f66ff);border-color:#2f66ff}
    button.good{background:linear-gradient(180deg,#22c55e,#16a34a);border-color:#16a34a}
    button.bad{background:linear-gradient(180deg,#ef4444,#dc2626);border-color:#dc2626}
    button.ghost{background:transparent}
    main{max-width:1500px;margin:0 auto;padding:14px 16px 24px}
    .tabs{display:flex;gap:8px;margin:10px 0 14px}
    .tab{padding:10px 12px;border-radius:12px;background:var(--panel2);border:1px solid var(--border);cursor:pointer;font-weight:800;color:var(--muted)}
    .tab.active{background:var(--panel);color:var(--text);border-color:#2b4a85}
    .grid{display:grid;gap:12px}
    .card{background:rgba(15,27,51,.9);border:1px solid var(--border);border-radius:16px;padding:12px}
    .card h2{margin:0 0 10px;font-size:13px;color:var(--muted);letter-spacing:.3px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .hint{color:var(--muted);font-size:12px}
    .split{display:grid;grid-template-columns: 1.1fr .9fr;gap:12px}
    @media (max-width: 980px){.split{grid-template-columns:1fr}}
    table{border-collapse:collapse;width:100%;min-width:1050px}
    th,td{border:1px solid rgba(31,51,93,.7);padding:6px 6px;text-align:center;font-size:12px}
    th{position:sticky;top:58px;background:rgba(12,22,43,.95);z-index:10}
    th.emp,td.emp{position:sticky;left:0;background:rgba(12,22,43,.95);z-index:15;text-align:left;font-weight:900;min-width:170px}
    td{background:rgba(9,15,28,.55)}
    .cell{display:flex;flex-direction:column;gap:2px;align-items:center;justify-content:center;min-height:32px;border-radius:10px}
    .chip{display:inline-flex;gap:6px;align-items:center;padding:3px 8px;border-radius:999px;background:var(--chip);border:1px solid rgba(31,51,93,.6);font-size:11px;color:var(--muted)}
    .s-M{background:rgba(79,140,255,.18);border:1px solid rgba(79,140,255,.45)}
    .s-A{background:rgba(245,158,11,.16);border:1px solid rgba(245,158,11,.45)}
    .s-N{background:rgba(231,238,252,.08);border:1px solid rgba(231,238,252,.20)}
    .s-OFF{background:rgba(34,197,94,.12);border:1px solid rgba(34,197,94,.35)}
    .s-VAC{background:rgba(168,85,247,.14);border:1px solid rgba(168,85,247,.40)}
    .s-X{background:rgba(239,68,68,.14);border:1px solid rgba(239,68,68,.40)}
    .viol{outline:2px solid var(--bad);box-shadow:0 0 0 2px rgba(239,68,68,.22) inset}
    .warn{outline:2px solid var(--warn)}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;background:rgba(12,22,43,.9);border:1px solid var(--border);font-weight:800}
    .kv{display:grid;grid-template-columns: 150px 1fr;gap:8px;align-items:center}
    .kv label{color:var(--muted);font-weight:800;font-size:12px}
    textarea{width:100%;min-height:120px;resize:vertical;background:rgba(9,15,28,.55);border:1px solid var(--border);color:var(--text);padding:10px;border-radius:14px}
    .list{display:flex;flex-direction:column;gap:8px}
    .empCard{padding:10px;border-radius:14px;border:1px solid var(--border);background:rgba(9,15,28,.55)}
    .empTop{display:flex;gap:8px;align-items:center;justify-content:space-between}
    .empTop b{font-size:13px}
    .mini{font-size:11px;color:var(--muted)}
    .dangerText{color:#ffb4b4}
    .okText{color:#bfffd2}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .footerNote{margin-top:10px;color:var(--muted);font-size:12px}
  </style>
</head>
<body>
<header>
  <div class="left">
    <h1>üóìÔ∏è Shift Scheduling SPA ‚Äî Safety Gate + Tiered Distribution</h1>
    <span class="chip" id="statusChip">Offline</span>
  </div>
  <div class="toolbar">
    <select id="yearSel"></select>
    <select id="monthSel"></select>
    <button class="ghost" id="btnLoad">Load</button>
    <button class="ghost" id="btnSave">Save</button>
    <button class="primary" id="btnGenerate">Generate</button>
    <button class="ghost" id="btnAssignDepots">Assign Depots</button>
    <button class="ghost" id="btnExport">Export CSV</button>
  </div>
</header>

<main>
  <div class="tabs">
    <div class="tab active" data-tab="schedule">Schedule</div>
    <div class="tab" data-tab="employees">Employees</div>
    <div class="tab" data-tab="settings">Settings</div>
  </div>

  <div id="view-schedule">
    <div class="split">
      <div class="card">
        <h2>Monthly Schedule</h2>
        <div class="row" style="justify-content:space-between;margin-bottom:8px">
          <span class="pill">Safety Gate: <span class="mono">N‚ÜíM/A forbidden</span>, <span class="mono">A‚ÜíM forbidden</span>, max <span class="mono">6</span> consecutive workdays</span>
          <span class="pill">Tier Flow: 1 Fixed ‚Üí 2 Rolling(Happy) ‚Üí 3 Rolling(M-force) ‚Üí 4 Rolling(Cleanup) ‚Üí 5 Joker</span>
        </div>
        <div style="overflow:auto;border-radius:14px;border:1px solid var(--border)">
          <table id="schedTable"></table>
        </div>
        <div class="footerNote">
          Tip: VAC always overrides. X is treated like non-working for flip/streak (configurable in code).
        </div>
      </div>
      <div class="card">
        <h2>Diagnostics</h2>
        <div class="row" style="margin-bottom:10px">
          <span class="chip">Coverage deficits are computed per Depot + Shift</span>
          <span class="chip">Violations are flagged per employee day</span>
        </div>
        <div id="diagBox" class="list"></div>
      </div>
    </div>
  </div>

  <div id="view-employees" style="display:none">
    <div class="card">
      <h2>Employees</h2>
      <div class="row" style="justify-content:space-between;margin-bottom:10px">
        <div class="hint">
          Types: <b>A</b> Fixed weekly pattern ¬∑ <b>B</b> Rolling weekly bucket ¬∑ <b>C</b> Joker (6 work + 1 OFF, prefers N/A, avoids M unless critical)
        </div>
        <button class="good" id="btnAddEmp">+ Add Employee</button>
      </div>
      <div id="empList" class="list"></div>
    </div>
  </div>

  <div id="view-settings" style="display:none">
    <div class="grid">
      <div class="card">
        <h2>API + Storage</h2>
        <div class="kv">
          <label>Google Apps Script Web App URL</label>
          <input id="apiUrl" placeholder="https://script.google.com/macros/s/AKfycbz_Ax4qk6l7tmebex2kP9e2KCz4twS960mH5D2JxF8RIa0h_OeiAC96uTNSMunQrvha/exec" />
        </div>
        <div class="hint" style="margin-top:8px">
          Expected endpoints:
          <span class="mono">GET ?action=load</span> ‚Üí { ok:true, data:{...} } ¬∑
          <span class="mono">POST</span> body { action:"save", payload:{...} }.
        </div>
      </div>

      <div class="card">
        <h2>Depots + Requirements</h2>
        <div class="kv">
          <label>Depots (comma-separated)</label>
          <input id="depotsInput" placeholder="Budaiya, IsaTown" />
        </div>
        <div class="hint" style="margin-top:8px">
          Requirements are per-depot per-shift (same for every day). You can extend this to per-day if you want.
        </div>
        <div style="margin-top:10px;overflow:auto">
          <table id="reqTable"></table>
        </div>
      </div>

      <div class="card">
        <h2>Advanced (JSON)</h2>
        <div class="hint">If you want to edit everything quickly, paste JSON here and click ‚ÄúApply JSON‚Äù.</div>
        <textarea id="jsonArea" class="mono"></textarea>
        <div class="row" style="margin-top:8px">
          <button id="btnRefreshJson" class="ghost">Refresh JSON</button>
          <button id="btnApplyJson" class="primary">Apply JSON</button>
          <button id="btnReset" class="bad">Reset All</button>
        </div>
      </div>
    </div>
  </div>
</main>

<script>
/* ============================
   SHIFT SCHEDULER SPA (Single-file)
   - Safety Gate (anti-flip, max streak)
   - Tiered distribution algorithm
   - Depot balancing (fair rotation)
   - Save/Load via Google Apps Script
   ============================ */

(() => {
  // ---- Constants ----
  const SHIFTS = ["M","A","N","OFF","VAC","X"];
  const WORK_SHIFTS = new Set(["M","A","N"]);
  const DOW = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];

  // Treat these as "rest-like" for flip/streak purposes:
  const REST_LIKE = new Set(["OFF","VAC","X"]);

  // ---- App State ----
  const state = {
    apiUrl: "",
    meta: {
      depots: ["Budaiya","IsaTown"],
      requirements: { // per depot
        Budaiya: { M:1, A:1, N:1 },
        IsaTown: { M:1, A:1, N:1 }
      }
    },
    employees: [
      // Sample:
      // { id:"e1", name:"A-Fixed-1", type:"A", fixedPattern:{Sun:"M",Mon:"M",Tue:"M",Wed:"M",Thu:"M",Fri:"OFF",Sat:"OFF"}, vacations:["2026-02-10"], depotWeights:{Budaiya:1, IsaTown:1} },
      // { id:"e2", name:"B-Rolling-1", type:"B", weeklyBucket:{M:1,A:2,N:2,OFF:2}, vacations:[], depotWeights:{Budaiya:1, IsaTown:1} },
      // { id:"e3", name:"C-Joker-1", type:"C", vacations:[], depotWeights:{Budaiya:1, IsaTown:1} },
    ],
    schedule: {
      // key "YYYY-MM": { empId: { "YYYY-MM-DD": {shift:"M", depot:"Budaiya"} } }
    }
  };

  // ---- UI Elements ----
  const el = {
    statusChip: document.getElementById("statusChip"),
    yearSel: document.getElementById("yearSel"),
    monthSel: document.getElementById("monthSel"),
    btnLoad: document.getElementById("btnLoad"),
    btnSave: document.getElementById("btnSave"),
    btnGenerate: document.getElementById("btnGenerate"),
    btnAssignDepots: document.getElementById("btnAssignDepots"),
    btnExport: document.getElementById("btnExport"),
    schedTable: document.getElementById("schedTable"),
    diagBox: document.getElementById("diagBox"),
    empList: document.getElementById("empList"),
    btnAddEmp: document.getElementById("btnAddEmp"),
    apiUrl: document.getElementById("apiUrl"),
    depotsInput: document.getElementById("depotsInput"),
    reqTable: document.getElementById("reqTable"),
    jsonArea: document.getElementById("jsonArea"),
    btnRefreshJson: document.getElementById("btnRefreshJson"),
    btnApplyJson: document.getElementById("btnApplyJson"),
    btnReset: document.getElementById("btnReset"),
  };

  // ---- Helpers (dates, ids, deep copy) ----
  const pad2 = n => String(n).padStart(2,"0");
  const ymKey = (y,m) => `${y}-${pad2(m)}`;
  const isoDate = (y,m,d) => `${y}-${pad2(m)}-${pad2(d)}`;
  const daysInMonth = (y,m) => new Date(y, m, 0).getDate(); // m=1..12
  const randId = () => "e_" + Math.random().toString(36).slice(2,10);
  const deepClone = obj => JSON.parse(JSON.stringify(obj));

  function monthDays(y,m){
    const n = daysInMonth(y,m);
    const days = [];
    for(let d=1; d<=n; d++){
      const dt = new Date(y, m-1, d);
      days.push({
        d,
        iso: isoDate(y,m,d),
        dow: dt.getDay(),
        dowName: DOW[dt.getDay()],
        // week index counted by Sundays inside the month:
        weekIndex: getWeekIndexInMonth(y,m,d)
      });
    }
    return days;
  }

  // Week index based on Sundays; resets each Sunday. If month starts mid-week, first partial week is weekIndex 0.
  function getWeekIndexInMonth(y,m,d){
    const dt = new Date(y,m-1,d);
    // count how many Sundays have occurred up to this date within the month
    let count = 0;
    for(let i=1;i<=d;i++){
      const t = new Date(y,m-1,i);
      if(t.getDay()===0) count++;
    }
    // If day itself is Sunday, it belongs to its own (new) week bucket.
    // We want first Sunday to be weekIndex 0. So subtract 1.
    return Math.max(0, count - 1);
  }

  function isSunday(iso){
    const dt = new Date(iso+"T00:00:00");
    return dt.getDay()===0;
  }

  // ---- Safety Gate ----
  function isFlipViolation(prevShift, nextShift){
    if(!prevShift) return false;
    if(REST_LIKE.has(prevShift) || REST_LIKE.has(nextShift)) return false;
    if(prevShift==="N" && (nextShift==="M" || nextShift==="A")) return true; // zero tolerance
    if(prevShift==="A" && nextShift==="M") return true;
    return false;
  }

  // Max consecutive WORK days: 6. Day 7 must be OFF (or VAC).
  function wouldBreakMaxStreak(currStreak, nextShift){
    if(!WORK_SHIFTS.has(nextShift)) return false;
    return currStreak >= 6;
  }

  // ---- Requirements ----
  function totalReqPerShift(){
    const out = {M:0,A:0,N:0};
    for(const depot of state.meta.depots){
      const r = state.meta.requirements[depot] || {M:0,A:0,N:0};
      out.M += (r.M||0); out.A += (r.A||0); out.N += (r.N||0);
    }
    return out;
  }

  // ---- Schedule accessors ----
  function getMonthStore(y,m){
    const k = ymKey(y,m);
    if(!state.schedule[k]) state.schedule[k] = {};
    return state.schedule[k];
  }
  function ensureEmpStore(monthStore, empId){
    if(!monthStore[empId]) monthStore[empId] = {};
    return monthStore[empId];
  }
  function getCell(monthStore, empId, iso){
    return monthStore?.[empId]?.[iso] || null;
  }
  function setCell(monthStore, empId, iso, cell){
    ensureEmpStore(monthStore, empId)[iso] = cell;
  }

  // ---- Core scheduler (Tiered) ----
  function generateMonth(y,m){
    const k = ymKey(y,m);
    const monthStore = getMonthStore(y,m);

    // init storage for all emps
    for(const e of state.employees) ensureEmpStore(monthStore, e.id);

    const days = monthDays(y,m);
    const reqTotal = totalReqPerShift();

    // runtime trackers
    const prevShift = {};     // empId -> last non-null shift as we iterate by date
    const streak = {};        // empId -> consecutive workdays
    for(const e of state.employees){ prevShift[e.id] = "OFF"; streak[e.id] = 0; }

    // 0) VAC override
    applyVacations(monthStore, days);

    // 1) Tier 1 ‚Äî Fixed employees first (whole month)
    for(const e of state.employees.filter(x=>x.type==="A")){
      for(const day of days){
        const cell = getCell(monthStore, e.id, day.iso);
        if(cell && cell.shift==="VAC") { prevShift[e.id]="VAC"; streak[e.id]=0; continue; }

        const desired = (e.fixedPattern?.[day.dowName] || "OFF");
        const safe = makeSafeShift(prevShift[e.id], streak[e.id], desired);

        setCell(monthStore, e.id, day.iso, { shift:safe, depot:"" });
        if(WORK_SHIFTS.has(safe)){ streak[e.id] += 1; } else { streak[e.id]=0; }
        prevShift[e.id] = safe;
      }
    }

    // 2..5) Week-by-week for Rolling + Joker (B + C), respecting weekly reset Sunday
    // Prepare Joker OFF staggering: exactly 1 OFF per week (unless VAC)
    // Rolling weekly buckets reset every Sunday.
    const rolling = state.employees.filter(x=>x.type==="B");
    const jokers  = state.employees.filter(x=>x.type==="C");

    // For fairness, we track per-employee shift counts + forced-M counts
    const fair = {};
    for(const e of state.employees){
      fair[e.id] = { forcedM:0, assigned: {M:0,A:0,N:0,OFF:0,VAC:0,X:0} };
    }

    // Build week groups by weekIndex
    const weeks = new Map();
    for(const day of days){
      if(!weeks.has(day.weekIndex)) weeks.set(day.weekIndex, []);
      weeks.get(day.weekIndex).push(day);
    }

    // Iterate weeks in order
    for(const [weekIndex, weekDays] of [...weeks.entries()].sort((a,b)=>a[0]-b[0])){
      // Reset rolling buckets at Sunday boundary, but for partial first week:
      // If the week contains a Sunday OR it's the first week in the month, reset at the first day in that group.
      const weekHasSunday = weekDays.some(d=>d.dow===0);
      if(weekHasSunday || weekIndex===0){
        for(const e of rolling){
          e._bucket = deepClone( normalizeBucket(e.weeklyBucket) );
        }
      }

      // Joker staggered OFF day: (employeeIndex + weekIndex) % 7 mapped onto day.dow
      const jokerOffDow = {};
      jokers.forEach((e, idx) => {
        jokerOffDow[e.id] = (idx + weekIndex) % 7; // 0..6 (Sun..Sat)
      });

      // Pre-calc remaining working shifts to enforce Rolling cleanup later
      // We‚Äôll update as we assign.
      for(const day of weekDays){
        // Compute deficits (global first)
        const deficits = calcDeficitsGlobal(monthStore, day.iso, reqTotal);

        // --- Tier 2: Rolling Happy Path (match bucket AND fills deficit) ---
        tier2RollingHappy(rolling, monthStore, day.iso, deficits, prevShift, streak, fair);

        // --- Tier 3: Rolling Morning Force (if M deficit still exists) ---
        tier3RollingForceMorning(rolling, monthStore, day.iso, deficits, prevShift, streak, fair);

        // --- Tier 4: Rolling Cleanup (prevent slacking; meet weekly work quota) ---
        // If we are near the end of the week, or if bucket remaining work is too high for remaining days,
        // force assignments (still safety-gated).
        tier4RollingCleanup(rolling, monthStore, day, weekDays, deficits, prevShift, streak, fair);

        // --- Tier 5: Joker Last Resort (N ‚Üí A ‚Üí M, exactly 1 OFF per week, prefers N/A; avoids M unless critical) ---
        tier5Joker(jokers, monthStore, day, deficits, prevShift, streak, fair, jokerOffDow);

        // Fill remaining unassigned (for B & C) as OFF by default (but respect remaining OFF quota for rolling when possible)
        fillUnassignedRest(rolling, jokers, monthStore, day.iso, prevShift, streak, fair);
      }

      // At end of week: if any rolling still has leftover bucket counts (work or OFF),
      // we do a final pass within the week to place remaining work shifts into OFF slots, respecting safety.
      finalizeRollingWeek(rolling, monthStore, weekDays, prevShift, streak, fair);
    }

    // Done: We purposely keep depot assignment separate.
    return { ok:true, key:k };
  }

  function normalizeBucket(b){
    const base = {M:0,A:0,N:0,OFF:0};
    if(!b) return { ...base, M:1, A:2, N:2, OFF:2 };
    for(const k of ["M","A","N","OFF"]) base[k] = Math.max(0, (b[k]||0)|0);
    return base;
  }

  function applyVacations(monthStore, days){
    for(const e of state.employees){
      const vac = (e.vacations || []).filter(Boolean);
      if(!vac.length) continue;
      for(const iso of vac){
        // only apply if in this month
        const dt = new Date(iso+"T00:00:00");
        const y = dt.getFullYear(), m = dt.getMonth()+1;
        if(ymKey(y,m) !== ymKey(selectedYear(), selectedMonth())) continue;
        // if valid date in month, set VAC
        if(days.some(d=>d.iso===iso)){
          setCell(monthStore, e.id, iso, { shift:"VAC", depot:"" });
        }
      }
    }
  }

  function makeSafeShift(prev, currStreak, desired){
    let s = desired;
    // VAC always allowed (already applied)
    if(s==="VAC") return "VAC";
    // anti-flip
    if(isFlipViolation(prev, s)) s = "OFF";
    // max streak
    if(wouldBreakMaxStreak(currStreak, s)) s = "OFF";
    return s;
  }

  function isAssigned(monthStore, empId, iso){
    const c = getCell(monthStore, empId, iso);
    return !!c; // any value means assigned
  }
  function isVac(monthStore, empId, iso){
    const c = getCell(monthStore, empId, iso);
    return c && c.shift==="VAC";
  }

  function assign(monthStore, emp, iso, shift, prevShift, streak, fair, meta={}){
    const prev = prevShift[emp.id] || "OFF";
    const safe = makeSafeShift(prev, streak[emp.id]||0, shift);

    // If already VAC, keep VAC (override)
    if(isVac(monthStore, emp.id, iso)){
      fair[emp.id].assigned.VAC++;
      prevShift[emp.id]="VAC"; streak[emp.id]=0;
      return { shift:"VAC", forced:false };
    }

    setCell(monthStore, emp.id, iso, { shift:safe, depot:"", ...meta });

    // update counters
    fair[emp.id].assigned[safe] = (fair[emp.id].assigned[safe]||0) + 1;
    if(WORK_SHIFTS.has(safe)){ streak[emp.id] = (streak[emp.id]||0) + 1; }
    else { streak[emp.id] = 0; }
    prevShift[emp.id] = safe;

    return { shift:safe, forced: !!meta.forced };
  }

  function calcDeficitsGlobal(monthStore, iso, reqTotal){
    const filled = {M:0,A:0,N:0};
    for(const e of state.employees){
      const c = getCell(monthStore, e.id, iso);
      if(c && WORK_SHIFTS.has(c.shift)) filled[c.shift] += 1;
    }
    return {
      M: Math.max(0, reqTotal.M - filled.M),
      A: Math.max(0, reqTotal.A - filled.A),
      N: Math.max(0, reqTotal.N - filled.N),
      _filled: filled
    };
  }

  // -------- Tier 2: Rolling Happy Path --------
  function tier2RollingHappy(rolling, monthStore, iso, deficits, prevShift, streak, fair){
    // prioritize by "most constrained" first: those with fewer options due to flip/streak + bucket
    const list = rolling
      .filter(e => !isAssigned(monthStore, e.id, iso) && !isVac(monthStore, e.id, iso))
      .map(e => {
        const b = e._bucket || normalizeBucket(e.weeklyBucket);
        const options = ["N","A","M"].filter(s => b[s]>0 && !isFlipViolation(prevShift[e.id], s) && !wouldBreakMaxStreak(streak[e.id]||0, s));
        return { e, optionsCount: options.length, b };
      })
      .sort((a,b)=> a.optionsCount - b.optionsCount || (fair[a.e.id].forcedM - fair[b.e.id].forcedM));

    for(const item of list){
      const e = item.e;
      const b = e._bucket;
      // pick shift that both matches bucket and reduces a deficit (priority: largest deficit)
      const picks = ["M","A","N"]
        .filter(s => deficits[s]>0 && b[s]>0)
        .sort((s1,s2)=> deficits[s2]-deficits[s1]);
      let chosen = null;
      for(const s of picks){
        if(!isFlipViolation(prevShift[e.id], s) && !wouldBreakMaxStreak(streak[e.id]||0, s)){
          chosen = s; break;
        }
      }
      if(!chosen) continue;

      const res = assign(monthStore, e, iso, chosen, prevShift, streak, fair);
      if(WORK_SHIFTS.has(res.shift)){
        deficits[res.shift] = Math.max(0, deficits[res.shift]-1);
        b[chosen] = Math.max(0, b[chosen]-1); // consume ORIGINAL chosen from bucket
      }
    }
  }

  // -------- Tier 3: Rolling Morning Force --------
  function tier3RollingForceMorning(rolling, monthStore, iso, deficits, prevShift, streak, fair){
    if(deficits.M<=0) return;
    // force M by converting A/N from bucket (prefer A first to preserve N for safety)
    const candidates = rolling
      .filter(e => !isAssigned(monthStore, e.id, iso) && !isVac(monthStore, e.id, iso))
      .filter(e => !isFlipViolation(prevShift[e.id], "M") && !wouldBreakMaxStreak(streak[e.id]||0, "M"))
      .map(e => {
        const b = e._bucket || normalizeBucket(e.weeklyBucket);
        const convertible = (b.A||0) + (b.N||0);
        return { e, b, convertible };
      })
      .filter(x => x.convertible>0)
      .sort((a,b)=> (fair[a.e.id].forcedM - fair[b.e.id].forcedM) || (b.convertible - a.convertible));

    for(const c of candidates){
      if(deficits.M<=0) break;
      const b = c.b;
      // convert A then N
      let from = null;
      if((b.A||0)>0) from="A";
      else if((b.N||0)>0) from="N";
      else continue;

      const res = assign(monthStore, c.e, iso, "M", prevShift, streak, fair, { forced:true, convertedFrom:from });
      if(res.shift==="M"){
        deficits.M = Math.max(0, deficits.M-1);
        b[from] = Math.max(0, b[from]-1);
        fair[c.e.id].forcedM++;
      }
    }
  }

  // -------- Tier 4: Rolling Cleanup (prevent slacking) --------
  function tier4RollingCleanup(rolling, monthStore, day, weekDays, deficits, prevShift, streak, fair){
    const iso = day.iso;
    // remaining days in this week including today
    const remainingDays = weekDays.filter(d=>d.iso>=iso).length;

    // decide which employees are in "panic" (too much remaining work for remaining days)
    const candidates = rolling
      .filter(e => !isAssigned(monthStore, e.id, iso) && !isVac(monthStore, e.id, iso))
      .map(e => {
        const b = e._bucket || normalizeBucket(e.weeklyBucket);
        const workLeft = (b.M||0)+(b.A||0)+(b.N||0);
        const offLeft  = (b.OFF||0);
        // if workLeft >= remainingDays, we must work almost every day -> panic
        const panic = workLeft >= remainingDays;
        return { e, b, workLeft, offLeft, panic };
      })
      .sort((a,b)=> (b.panic - a.panic) || (b.workLeft - a.workLeft));

    for(const c of candidates){
      const e = c.e, b = c.b;
      // If not panic and no deficits, skip (don‚Äôt create too much surplus)
      const anyDef = deficits.M+deficits.A+deficits.N;
      if(!c.panic && anyDef<=0) continue;

      // Choose best shift to reduce deficits first, else consume bucket work.
      const pref = ["N","A","M"]; // safer preference (avoids A->M problems)
      let chosen = null;

      // Try to satisfy deficit with available bucket
      const deficitOrder = ["M","A","N"].sort((s1,s2)=>deficits[s2]-deficits[s1]);
      for(const s of deficitOrder){
        if(deficits[s]<=0) continue;
        if((b[s]||0)<=0) continue;
        if(isFlipViolation(prevShift[e.id], s)) continue;
        if(wouldBreakMaxStreak(streak[e.id]||0, s)) continue;
        chosen = s; break;
      }

      // Otherwise, just consume remaining work shifts from bucket (panic cleanup)
      if(!chosen){
        for(const s of pref){
          if((b[s]||0)<=0) continue;
          if(isFlipViolation(prevShift[e.id], s)) continue;
          if(wouldBreakMaxStreak(streak[e.id]||0, s)) continue;
          chosen = s; break;
        }
      }

      if(!chosen) continue;
      const res = assign(monthStore, e, iso, chosen, prevShift, streak, fair);
      if(WORK_SHIFTS.has(res.shift)){
        if(deficits[res.shift]>0) deficits[res.shift] = Math.max(0, deficits[res.shift]-1);
        b[chosen] = Math.max(0, b[chosen]-1);
      }
    }
  }

  // -------- Tier 5: Joker Last Resort --------
  function tier5Joker(jokers, monthStore, day, deficits, prevShift, streak, fair, jokerOffDow){
    const iso = day.iso;
    // If already fully covered, joker should avoid working unless it helps enforce 6/1 cadence.
    // Joker rules: 6 work + 1 OFF per week; prefers N/A; avoids M unless critical deficit.
    const list = jokers
      .filter(e => !isAssigned(monthStore, e.id, iso) && !isVac(monthStore, e.id, iso))
      .sort((a,b)=> (fair[a.id].assigned.OFF - fair[b.id].assigned.OFF)); // crude fairness

    for(const e of list){
      // weekly OFF day (staggered)
      const mustOff = (day.dow === jokerOffDow[e.id]);

      if(mustOff){
        assign(monthStore, e, iso, "OFF", prevShift, streak, fair);
        continue;
      }

      // If a joker is near max streak, force OFF
      if(wouldBreakMaxStreak(streak[e.id]||0, "N")){
        assign(monthStore, e, iso, "OFF", prevShift, streak, fair);
        continue;
      }

      // Priority to fill deficits N -> A -> M (M only if critical)
      let chosen = null;
      if(deficits.N>0 && !isFlipViolation(prevShift[e.id], "N")) chosen="N";
      else if(deficits.A>0 && !isFlipViolation(prevShift[e.id], "A")) chosen="A";
      else if(deficits.M>0 && !isFlipViolation(prevShift[e.id], "M")) chosen="M";

      // If no deficit, joker should still work to maintain 6/1, but prefer N/A and avoid M
      if(!chosen){
        if(!isFlipViolation(prevShift[e.id], "N")) chosen="N";
        else if(!isFlipViolation(prevShift[e.id], "A")) chosen="A";
        else chosen="OFF";
      }

      const res = assign(monthStore, e, iso, chosen, prevShift, streak, fair);
      if(WORK_SHIFTS.has(res.shift) && deficits[res.shift]>0){
        deficits[res.shift] = Math.max(0, deficits[res.shift]-1);
      }
    }
  }

  function fillUnassignedRest(rolling, jokers, monthStore, iso, prevShift, streak, fair){
    // Rolling: if they still have OFF quota, consume OFF; else default OFF anyway (we‚Äôll correct at finalize)
    for(const e of rolling){
      if(isAssigned(monthStore, e.id, iso) || isVac(monthStore, e.id, iso)) continue;
      const b = e._bucket || normalizeBucket(e.weeklyBucket);
      if((b.OFF||0)>0){
        assign(monthStore, e, iso, "OFF", prevShift, streak, fair);
        b.OFF = Math.max(0, b.OFF-1);
      } else {
        assign(monthStore, e, iso, "OFF", prevShift, streak, fair);
      }
    }
    // Jokers: if still unassigned, OFF
    for(const e of jokers){
      if(isAssigned(monthStore, e.id, iso) || isVac(monthStore, e.id, iso)) continue;
      assign(monthStore, e, iso, "OFF", prevShift, streak, fair);
    }
  }

  function finalizeRollingWeek(rolling, monthStore, weekDays, prevShift, streak, fair){
    // Goal: empty remaining work in bucket into OFF slots (still safety-gated).
    // We iterate through weekDays and try to upgrade OFF -> work if bucket work remains and it won't violate safety.
    for(const e of rolling){
      const b = e._bucket || normalizeBucket(e.weeklyBucket);
      let workLeft = (b.M||0)+(b.A||0)+(b.N||0);
      if(workLeft<=0) continue;

      for(const day of weekDays){
        if(workLeft<=0) break;
        const iso = day.iso;
        const c = getCell(monthStore, e.id, iso);
        if(!c || c.shift!=="OFF") continue; // only convert OFF
        if(isVac(monthStore, e.id, iso)) continue;

        // choose remaining work (prefer N then A then M for safety)
        const choices = ["N","A","M"].filter(s => (b[s]||0)>0);
        let chosen = null;
        for(const s of choices){
          // simulate previous day shift within this week by looking at actual previous date in month
          const prevIso = prevDateIso(iso);
          const prevC = getCell(monthStore, e.id, prevIso);
          const prev = prevC?.shift || "OFF";
          // compute streak up to previous day (approx within week; good enough for weekly finalize)
          const st = computeStreakUpTo(monthStore, e.id, prevIso);
          if(isFlipViolation(prev, s)) continue;
          if(wouldBreakMaxStreak(st, s)) continue;
          chosen = s; break;
        }
        if(!chosen) continue;

        // assign & consume
        setCell(monthStore, e.id, iso, { shift:chosen, depot:"", cleanup:true });
        fair[e.id].assigned[chosen] = (fair[e.id].assigned[chosen]||0)+1;
        b[chosen] = Math.max(0, b[chosen]-1);
        workLeft = (b.M||0)+(b.A||0)+(b.N||0);
      }
    }
  }

  function prevDateIso(iso){
    const dt = new Date(iso+"T00:00:00");
    dt.setDate(dt.getDate()-1);
    return `${dt.getFullYear()}-${pad2(dt.getMonth()+1)}-${pad2(dt.getDate())}`;
  }

  function computeStreakUpTo(monthStore, empId, iso){
    // counts consecutive work days ending at iso
    let dt = new Date(iso+"T00:00:00");
    let count = 0;
    for(let i=0;i<40;i++){ // safe cap
      const curIso = `${dt.getFullYear()}-${pad2(dt.getMonth()+1)}-${pad2(dt.getDate())}`;
      const c = getCell(monthStore, empId, curIso);
      const s = c?.shift || "OFF";
      if(WORK_SHIFTS.has(s)) count++;
      else break;
      dt.setDate(dt.getDate()-1);
    }
    return count;
  }

  // ---- Depot Balancing ----
  function assignDepotsForMonth(y,m){
    const monthStore = getMonthStore(y,m);
    const days = monthDays(y,m);
    const depots = state.meta.depots;

    // usage tracker per employee per depot
    const usage = {};
    for(const e of state.employees){
      usage[e.id] = {};
      for(const d of depots) usage[e.id][d]=0;
    }

    // prime usage from existing schedule (so repeated runs keep rotation)
    for(const e of state.employees){
      const store = monthStore[e.id] || {};
      for(const iso in store){
        const c = store[iso];
        if(c?.depot && depots.includes(c.depot)) usage[e.id][c.depot]++;
      }
    }

    for(const day of days){
      // for each shift, fill depot requirements using a greedy fair allocator
      for(const shift of ["M","A","N"]){
        // employees working this shift
        const workers = state.employees
          .filter(e => (getCell(monthStore, e.id, day.iso)?.shift === shift))
          .map(e => e.id);

        // clear previous depots for this day+shift (we reassign)
        for(const empId of workers){
          const c = getCell(monthStore, empId, day.iso);
          if(c) c.depot = "";
        }

        // depot needs
        const needs = {};
        for(const depot of depots){
          needs[depot] = (state.meta.requirements[depot]?.[shift]||0);
        }

        // Greedy: repeatedly assign one person to the depot with remaining need,
        // choosing employee with "lowest normalized usage" for that depot (fair rotation),
        // also respecting employee depotWeights (quota preference).
        const unassigned = new Set(workers);

        // helper score
        const score = (empId, depot) => {
          const emp = state.employees.find(x=>x.id===empId);
          const w = Math.max(0.1, (emp?.depotWeights?.[depot] ?? 1)); // higher weight = should go more often
          // normalized: usage / weight
          return (usage[empId][depot] || 0) / w;
        };

        // First satisfy hard needs per depot
        for(const depot of depots){
          while(needs[depot]>0 && unassigned.size>0){
            let best = null, bestScore = Infinity;
            for(const empId of unassigned){
              const s = score(empId, depot);
              if(s < bestScore){ bestScore=s; best=empId; }
            }
            if(!best) break;
            const c = getCell(monthStore, best, day.iso);
            if(c){ c.depot = depot; usage[best][depot]++; }
            unassigned.delete(best);
            needs[depot]--;
          }
        }

        // Any leftover workers: place into depot with lowest current coverage for that shift (balance)
        const countByDepot = {};
        for(const depot of depots) countByDepot[depot]=0;
        for(const empId of workers){
          const c = getCell(monthStore, empId, day.iso);
          if(c?.depot) countByDepot[c.depot] = (countByDepot[c.depot]||0)+1;
        }
        for(const empId of unassigned){
          // choose depot with minimum count (tie -> best fairness score)
          let target = depots[0];
          for(const depot of depots){
            if(countByDepot[depot] < countByDepot[target]) target = depot;
          }
          // tie-break with fairness
          let bestDepot = target, bestScore = score(empId, target);
          for(const depot of depots){
            if(countByDepot[depot]===countByDepot[target]){
              const s = score(empId, depot);
              if(s < bestScore){ bestScore=s; bestDepot=depot; }
            }
          }
          const c = getCell(monthStore, empId, day.iso);
          if(c){ c.depot = bestDepot; usage[empId][bestDepot]++; countByDepot[bestDepot]++; }
        }
      }
    }
  }

  // ---- Diagnostics (deficits + violations) ----
  function analyzeMonth(y,m){
    const monthStore = getMonthStore(y,m);
    const days = monthDays(y,m);
    const depots = state.meta.depots;

    const issues = [];

    // 1) Anti-flip violations + max streak warnings (streak>6 should not happen; flag if it does)
    for(const e of state.employees){
      let prev = "OFF";
      let st = 0;
      for(const day of days){
        const c = getCell(monthStore, e.id, day.iso);
        const s = c?.shift || "";
        if(s==="") continue;
        const viol = isFlipViolation(prev, s);
        if(WORK_SHIFTS.has(s)) st++; else st=0;
        if(viol){
          issues.push({ type:"bad", msg:`Safety violation: ${e.name} ${day.iso} (${prev} ‚Üí ${s})` });
        }
        if(st>6){
          issues.push({ type:"warn", msg:`Max-streak warning: ${e.name} reached ${st} workdays by ${day.iso}` });
        }
        // prev shift: treat OFF/VAC/X as "rest-like" to not cause flip checks later
        prev = s;
      }
    }

    // 2) Coverage deficits per depot & shift (requires depot assignment to be meaningful)
    for(const day of days){
      for(const depot of depots){
        for(const shift of ["M","A","N"]){
          const req = state.meta.requirements[depot]?.[shift] || 0;
          let have = 0;
          for(const e of state.employees){
            const c = getCell(monthStore, e.id, day.iso);
            if(c && c.shift===shift && c.depot===depot) have++;
          }
          if(have < req){
            issues.push({ type:"bad", msg:`Coverage deficit: ${day.iso} ‚Äî ${depot} ${shift}: need ${req}, have ${have}` });
          }
        }
      }
    }

    // 3) Rolling bucket compliance (informational)
    // We summarize per rolling per week: assigned counts vs bucket
    const rolling = state.employees.filter(x=>x.type==="B");
    const weeks = new Map();
    for(const day of days){
      if(!weeks.has(day.weekIndex)) weeks.set(day.weekIndex, []);
      weeks.get(day.weekIndex).push(day);
    }
    for(const e of rolling){
      for(const [w, wDays] of weeks){
        const assigned = {M:0,A:0,N:0,OFF:0};
        for(const d of wDays){
          const s = getCell(monthStore, e.id, d.iso)?.shift;
          if(assigned[s]!==undefined) assigned[s]++;
        }
        const bucket = normalizeBucket(e.weeklyBucket);
        // We only flag if they are *below total work* significantly (slacking)
        const workA = assigned.M+assigned.A+assigned.N;
        const workB = bucket.M+bucket.A+bucket.N;
        if(workA < workB){
          issues.push({ type:"warn", msg:`Rolling under-fill: ${e.name} week#${w} work ${workA}/${workB} (bucket).` });
        }
      }
    }

    return issues;
  }

  // ---- Rendering ----
  function render(){
    renderSettings();
    renderEmployees();
    renderRequirementsTable();
    renderSchedule();
  }

  function renderSettings(){
    el.apiUrl.value = state.apiUrl || "";
    el.depotsInput.value = (state.meta.depots||[]).join(", ");
    setStatus(state.apiUrl ? "API configured" : "Offline", !!state.apiUrl);
    refreshJsonArea();
  }

  function renderRequirementsTable(){
    const depots = state.meta.depots;
    const header = `<thead><tr><th>Depot</th><th>M</th><th>A</th><th>N</th></tr></thead>`;
    let body = "<tbody>";
    for(const d of depots){
      const r = state.meta.requirements[d] || {M:0,A:0,N:0};
      body += `<tr>
        <td style="text-align:left;font-weight:900">${escapeHtml(d)}</td>
        <td><input data-depot="${escapeAttr(d)}" data-shift="M" type="number" min="0" value="${r.M||0}" style="width:70px"/></td>
        <td><input data-depot="${escapeAttr(d)}" data-shift="A" type="number" min="0" value="${r.A||0}" style="width:70px"/></td>
        <td><input data-depot="${escapeAttr(d)}" data-shift="N" type="number" min="0" value="${r.N||0}" style="width:70px"/></td>
      </tr>`;
    }
    body += "</tbody>";
    el.reqTable.innerHTML = header + body;

    // hook inputs
    el.reqTable.querySelectorAll("input").forEach(inp=>{
      inp.addEventListener("change", () => {
        const depot = inp.getAttribute("data-depot");
        const shift = inp.getAttribute("data-shift");
        const v = Math.max(0, parseInt(inp.value||"0",10) || 0);
        if(!state.meta.requirements[depot]) state.meta.requirements[depot] = {M:0,A:0,N:0};
        state.meta.requirements[depot][shift] = v;
        refreshJsonArea();
        renderSchedule();
      });
    });
  }

  function renderEmployees(){
    el.empList.innerHTML = "";
    if(!state.employees.length){
      el.empList.innerHTML = `<div class="empCard"><b>No employees yet.</b><div class="mini">Click ‚ÄúAdd Employee‚Äù.</div></div>`;
      return;
    }

    for(const e of state.employees){
      const vac = (e.vacations||[]).join(", ");
      const weights = state.meta.depots.map(d=>`${d}:${(e.depotWeights?.[d] ?? 1)}`).join(", ");

      const fixedPattern = e.type==="A"
        ? DOW.map(d=>`${d}:${e.fixedPattern?.[d]||"OFF"}`).join(", ")
        : "";

      const bucket = e.type==="B"
        ? `M:${e.weeklyBucket?.M??1}, A:${e.weeklyBucket?.A??2}, N:${e.weeklyBucket?.N??2}, OFF:${e.weeklyBucket?.OFF??2}`
        : "";

      const card = document.createElement("div");
      card.className = "empCard";
      card.innerHTML = `
        <div class="empTop">
          <div>
            <b>${escapeHtml(e.name||"Unnamed")}</b>
            <div class="mini">ID: <span class="mono">${escapeHtml(e.id)}</span> ¬∑ Type: <span class="mono">${escapeHtml(e.type)}</span></div>
          </div>
          <div class="row">
            <button class="ghost" data-act="edit">Edit</button>
            <button class="bad" data-act="del">Delete</button>
          </div>
        </div>
        <div class="mini" style="margin-top:8px">
          <div><span class="chip">Vacations:</span> <span class="mono">${escapeHtml(vac||"")}</span></div>
          <div><span class="chip">Depot Weights:</span> <span class="mono">${escapeHtml(weights)}</span></div>
          ${e.type==="A" ? `<div><span class="chip">Fixed Pattern:</span> <span class="mono">${escapeHtml(fixedPattern)}</span></div>` : ""}
          ${e.type==="B" ? `<div><span class="chip">Weekly Bucket:</span> <span class="mono">${escapeHtml(bucket)}</span></div>` : ""}
          ${e.type==="C" ? `<div class="okText">Joker: 6 work + 1 OFF weekly ¬∑ priority N‚ÜíA‚ÜíM ¬∑ avoids M unless critical</div>` : ""}
        </div>
      `;

      card.querySelector('[data-act="del"]').addEventListener("click", () => {
        if(confirm(`Delete ${e.name}?`)){
          state.employees = state.employees.filter(x=>x.id!==e.id);
          // also remove schedule rows
          for(const k of Object.keys(state.schedule)){
            if(state.schedule[k]?.[e.id]) delete state.schedule[k][e.id];
          }
          refreshJsonArea();
          render();
        }
      });

      card.querySelector('[data-act="edit"]').addEventListener("click", () => {
        openEmpEditor(e.id);
      });

      el.empList.appendChild(card);
    }
  }

  function openEmpEditor(empId){
    const e = state.employees.find(x=>x.id===empId);
    if(!e) return;

    const depots = state.meta.depots;

    const modal = document.createElement("div");
    modal.style.position="fixed";
    modal.style.inset="0";
    modal.style.background="rgba(0,0,0,.55)";
    modal.style.display="flex";
    modal.style.alignItems="center";
    modal.style.justifyContent="center";
    modal.style.zIndex="9999";
    modal.innerHTML = `
      <div style="width:min(980px,92vw);max-height:86vh;overflow:auto;background:rgba(15,27,51,.97);border:1px solid var(--border);border-radius:18px;padding:12px">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div><b>Edit Employee</b> <span class="mini mono">${escapeHtml(e.id)}</span></div>
          <button class="ghost" data-close>Close</button>
        </div>
        <div class="grid" style="margin-top:10px">
          <div class="card">
            <h2>Basics</h2>
            <div class="kv"><label>Name</label><input data-k="name" value="${escapeAttr(e.name||"")}" /></div>
            <div class="kv"><label>Type</label>
              <select data-k="type">
                <option value="A" ${e.type==="A"?"selected":""}>A (Fixed)</option>
                <option value="B" ${e.type==="B"?"selected":""}>B (Rolling)</option>
                <option value="C" ${e.type==="C"?"selected":""}>C (Joker)</option>
              </select>
            </div>
            <div class="kv"><label>Vacations (ISO dates, comma)</label><input data-k="vacations" value="${escapeAttr((e.vacations||[]).join(", "))}" placeholder="2026-02-10, 2026-02-11"/></div>
          </div>

          <div class="card">
            <h2>Depot Weights (Fair Rotation)</h2>
            <div class="hint">Higher weight = employee should be assigned to that depot more often (relative).</div>
            <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(190px,1fr));margin-top:8px;gap:8px">
              ${depots.map(d=>{
                const v = e.depotWeights?.[d] ?? 1;
                return `<div class="kv"><label class="mono">${escapeHtml(d)}</label><input data-w="${escapeAttr(d)}" type="number" min="0" step="1" value="${v}"/></div>`;
              }).join("")}
            </div>
          </div>

          <div class="card" data-block="fixed" style="${e.type==="A"?"":"display:none"}">
            <h2>Fixed Pattern (A)</h2>
            <div class="hint">Use shifts M/A/N/OFF. VAC is managed via vacation dates.</div>
            <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:8px;margin-top:8px">
              ${DOW.map(d=>{
                const v = e.fixedPattern?.[d] || "OFF";
                return `
                  <div class="kv">
                    <label class="mono">${d}</label>
                    <select data-f="${d}">
                      ${["M","A","N","OFF"].map(s=>`<option value="${s}" ${v===s?"selected":""}>${s}</option>`).join("")}
                    </select>
                  </div>
                `;
              }).join("")}
            </div>
          </div>

          <div class="card" data-block="rolling" style="${e.type==="B"?"":"display:none"}">
            <h2>Weekly Bucket (B)</h2>
            <div class="hint">Resets every Sunday. Example: 1M, 2A, 2N, 2OFF.</div>
            <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:8px;margin-top:8px">
              ${["M","A","N","OFF"].map(s=>{
                const v = e.weeklyBucket?.[s] ?? (s==="M"?1 : s==="OFF"?2 : 2);
                return `<div class="kv"><label class="mono">${s}</label><input data-b="${s}" type="number" min="0" step="1" value="${v}"/></div>`;
              }).join("")}
            </div>
          </div>

          <div class="card" data-block="joker" style="${e.type==="C"?"":"display:none"}">
            <h2>Joker Notes (C)</h2>
            <div class="hint">
              The algorithm enforces 1 staggered OFF/week (unless VAC). Work preference order: N ‚Üí A ‚Üí M.
              Morning is only selected to cover deficits (or if N/A impossible).
            </div>
          </div>

          <div class="row" style="justify-content:flex-end">
            <button class="primary" data-save>Save Changes</button>
          </div>
        </div>
      </div>
    `;

    // show/hide blocks on type change
    const typeSel = modal.querySelector('select[data-k="type"]');
    const fixedBlock = modal.querySelector('[data-block="fixed"]');
    const rollingBlock = modal.querySelector('[data-block="rolling"]');
    const jokerBlock = modal.querySelector('[data-block="joker"]');
    typeSel.addEventListener("change", ()=>{
      const t = typeSel.value;
      fixedBlock.style.display = (t==="A") ? "" : "none";
      rollingBlock.style.display = (t==="B") ? "" : "none";
      jokerBlock.style.display = (t==="C") ? "" : "none";
    });

    modal.querySelector("[data-close]").addEventListener("click", ()=> modal.remove());

    modal.querySelector("[data-save]").addEventListener("click", ()=>{
      // basics
      e.name = modal.querySelector('input[data-k="name"]').value.trim() || "Unnamed";
      e.type = modal.querySelector('select[data-k="type"]').value;

      // vacations
      const vacRaw = modal.querySelector('input[data-k="vacations"]').value;
      e.vacations = vacRaw.split(",").map(s=>s.trim()).filter(s=>/^\d{4}-\d{2}-\d{2}$/.test(s));

      // weights
      e.depotWeights = e.depotWeights || {};
      modal.querySelectorAll("input[data-w]").forEach(inp=>{
        const depot = inp.getAttribute("data-w");
        e.depotWeights[depot] = Math.max(0, parseInt(inp.value||"0",10) || 0);
      });

      // fixed pattern
      if(e.type==="A"){
        e.fixedPattern = e.fixedPattern || {};
        modal.querySelectorAll("select[data-f]").forEach(sel=>{
          const d = sel.getAttribute("data-f");
          e.fixedPattern[d] = sel.value;
        });
        // remove rolling bucket
        delete e.weeklyBucket;
      }

      // rolling bucket
      if(e.type==="B"){
        e.weeklyBucket = e.weeklyBucket || {M:1,A:2,N:2,OFF:2};
        modal.querySelectorAll("input[data-b]").forEach(inp=>{
          const s = inp.getAttribute("data-b");
          e.weeklyBucket[s] = Math.max(0, parseInt(inp.value||"0",10) || 0);
        });
        // remove fixed pattern
        delete e.fixedPattern;
      }

      // joker (no extra fields required)
      if(e.type==="C"){
        delete e.fixedPattern;
        delete e.weeklyBucket;
      }

      refreshJsonArea();
      render();
      modal.remove();
    });

    document.body.appendChild(modal);
  }

  function renderSchedule(){
    const y = selectedYear(), m = selectedMonth();
    const monthStore = getMonthStore(y,m);
    const days = monthDays(y,m);

    // header
    let html = `<thead><tr><th class="emp">Employee</th>`;
    for(const day of days){
      html += `<th>${day.d}<div class="mini">${day.dowName}</div></th>`;
    }
    html += `</tr></thead><tbody>`;

    // body
    for(const e of state.employees){
      html += `<tr><td class="emp">${escapeHtml(e.name)}<div class="mini mono">${escapeHtml(e.type)}</div></td>`;
      let prev = "OFF";
      for(const day of days){
        const c = getCell(monthStore, e.id, day.iso) || null;
        const s = c?.shift || "";
        const depot = c?.depot || "";
        const viol = s ? isFlipViolation(prev, s) : false;
        const classS = s ? `s-${s}` : "";
        const cls = ["cell", classS, viol ? "viol" : ""].join(" ");
        html += `<td><div class="${cls}">
          <div class="mono" style="font-weight:900">${escapeHtml(s)}</div>
          <div class="mini">${escapeHtml(depot||"")}</div>
        </div></td>`;
        prev = s || prev;
      }
      html += `</tr>`;
    }
    html += `</tbody>`;
    el.schedTable.innerHTML = html;

    renderDiagnostics();
  }

  function renderDiagnostics(){
    const y = selectedYear(), m = selectedMonth();
    const issues = analyzeMonth(y,m);

    el.diagBox.innerHTML = "";
    if(!issues.length){
      el.diagBox.innerHTML = `<div class="empCard"><b class="okText">‚úÖ No deficits/violations detected (with current depot assignment).</b>
        <div class="mini">If you haven‚Äôt clicked ‚ÄúAssign Depots‚Äù yet, coverage per depot may still show deficits.</div>
      </div>`;
      return;
    }

    // Show most important first
    const sorted = issues.sort((a,b)=> (a.type===b.type?0 : (a.type==="bad"?-1:1)));
    for(const it of sorted.slice(0,220)){
      const div = document.createElement("div");
      div.className = "empCard";
      div.innerHTML = `<b class="${it.type==="bad"?"dangerText":""}">${it.type==="bad"?"‚ùå":"‚ö†Ô∏è"} ${escapeHtml(it.msg)}</b>`;
      el.diagBox.appendChild(div);
    }
    if(sorted.length>220){
      const div = document.createElement("div");
      div.className = "empCard";
      div.innerHTML = `<b class="mini">Showing 220 / ${sorted.length} issues.</b>`;
      el.diagBox.appendChild(div);
    }
  }

  // ---- JSON area ----
  function refreshJsonArea(){
    el.jsonArea.value = JSON.stringify({
      apiUrl: state.apiUrl,
      meta: state.meta,
      employees: state.employees,
      schedule: state.schedule
    }, null, 2);
  }
  function applyJsonFromArea(){
    const raw = el.jsonArea.value.trim();
    if(!raw) return;
    try{
      const obj = JSON.parse(raw);
      // shallow validate minimal shape
      state.apiUrl = obj.apiUrl || "";
      state.meta = obj.meta || state.meta;
      state.employees = obj.employees || [];
      state.schedule = obj.schedule || {};
      // ensure requirements/depots exist
      state.meta.depots = (state.meta.depots||[]).map(s=>String(s).trim()).filter(Boolean);
      state.meta.requirements = state.meta.requirements || {};
      for(const d of state.meta.depots){
        if(!state.meta.requirements[d]) state.meta.requirements[d] = {M:0,A:0,N:0};
      }
      // ensure employee ids exist
      for(const e of state.employees){
        if(!e.id) e.id = randId();
        if(!e.depotWeights) e.depotWeights = {};
        for(const d of state.meta.depots){
          if(e.depotWeights[d]===undefined) e.depotWeights[d]=1;
        }
        if(!["A","B","C"].includes(e.type)) e.type="A";
        e.vacations = (e.vacations||[]).map(String);
      }
      render();
      alert("JSON applied.");
    }catch(err){
      alert("Invalid JSON: " + err.message);
    }
  }

  // ---- API calls ----
  async function apiLoad(){
    const url = (state.apiUrl||"").trim();
    if(!url) return alert("Set the Apps Script URL in Settings first.");
    setStatus("Loading...", true);
    try{
      const res = await fetch(url + "?action=load", { method:"GET" });
      const json = await res.json();
      if(!json?.ok) throw new Error("API returned not-ok");
      const data = json.data || {};
      state.apiUrl = url;
      state.meta = data.meta || state.meta;
      state.employees = data.employees || [];
      state.schedule = data.schedule || {};
      // normalize
      state.meta.depots = (state.meta.depots||[]).map(s=>String(s).trim()).filter(Boolean);
      state.meta.requirements = state.meta.requirements || {};
      for(const d of state.meta.depots){
        if(!state.meta.requirements[d]) state.meta.requirements[d] = {M:0,A:0,N:0};
      }
      for(const e of state.employees){
        if(!e.id) e.id = randId();
        if(!e.depotWeights) e.depotWeights = {};
        for(const d of state.meta.depots){
          if(e.depotWeights[d]===undefined) e.depotWeights[d]=1;
        }
        e.vacations = (e.vacations||[]).map(String);
      }
      render();
      setStatus("Loaded", true);
    }catch(err){
      console.error(err);
      setStatus("Load failed", false);
      alert("Load failed: " + err.message);
    }
  }

  async function apiSave(){
    const url = (state.apiUrl||"").trim();
    if(!url) return alert("Set the Apps Script URL in Settings first.");
    setStatus("Saving...", true);
    try{
      const payload = { meta: state.meta, employees: state.employees, schedule: state.schedule };
      const res = await fetch(url, {
        method:"POST",
        body: JSON.stringify({ action:"save", payload }),
        headers: { "Content-Type":"text/plain;charset=utf-8" } // Apps Script friendly
      });
      // Apps Script might return text; attempt json
      const text = await res.text();
      let ok = true;
      try{ const j = JSON.parse(text); ok = !!j.ok; }catch(_){}
      if(!ok) throw new Error("API save not confirmed");
      setStatus("Saved", true);
      alert("Saved.");
    }catch(err){
      console.error(err);
      setStatus("Save failed", false);
      alert("Save failed: " + err.message);
    }
  }

  function setStatus(text, ok){
    el.statusChip.textContent = text;
    el.statusChip.style.background = ok ? "rgba(34,197,94,.12)" : "rgba(239,68,68,.14)";
    el.statusChip.style.borderColor = ok ? "rgba(34,197,94,.35)" : "rgba(239,68,68,.40)";
    el.statusChip.style.color = ok ? "#bfffd2" : "#ffb4b4";
  }

  // ---- Export CSV ----
  function exportCSV(){
    const y = selectedYear(), m = selectedMonth();
    const monthStore = getMonthStore(y,m);
    const days = monthDays(y,m);

    let csv = "\uFEFFEmployee,Type," + days.map(d=>d.iso).join(",") + "\n";
    for(const e of state.employees){
      const row = [];
      row.push(csvEscape(e.name||""));
      row.push(csvEscape(e.type||""));
      for(const d of days){
        const c = getCell(monthStore, e.id, d.iso);
        const v = c ? `${c.shift||""}${c.depot?(" @"+c.depot):""}` : "";
        row.push(csvEscape(v));
      }
      csv += row.join(",") + "\n";
    }

    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `schedule_${ymKey(y,m)}.csv`;
    a.click();
  }
  const csvEscape = (s)=> `"${String(s).replaceAll('"','""')}"`;

  // ---- UI wiring ----
  function selectedYear(){ return parseInt(el.yearSel.value,10); }
  function selectedMonth(){ return parseInt(el.monthSel.value,10); }

  function initDateSelectors(){
    const now = new Date();
    const curY = now.getFullYear();
    for(let y=curY-1;y<=curY+3;y++){
      const opt = document.createElement("option");
      opt.value = String(y); opt.textContent = String(y);
      el.yearSel.appendChild(opt);
    }
    const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    months.forEach((name,i)=>{
      const opt = document.createElement("option");
      opt.value = String(i+1); opt.textContent = `${pad2(i+1)} - ${name}`;
      el.monthSel.appendChild(opt);
    });
    el.yearSel.value = String(curY);
    el.monthSel.value = String(now.getMonth()+1);

    el.yearSel.addEventListener("change", ()=> renderSchedule());
    el.monthSel.addEventListener("change", ()=> renderSchedule());
  }

  // tabs
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
      t.classList.add("active");
      const tab = t.getAttribute("data-tab");
      document.getElementById("view-schedule").style.display = tab==="schedule" ? "" : "none";
      document.getElementById("view-employees").style.display = tab==="employees" ? "" : "none";
      document.getElementById("view-settings").style.display = tab==="settings" ? "" : "none";
    });
  });

  // buttons
  el.btnAddEmp.addEventListener("click", ()=>{
    const e = {
      id: randId(),
      name: "New Employee",
      type: "A",
      fixedPattern: {Sun:"M",Mon:"M",Tue:"M",Wed:"M",Thu:"M",Fri:"OFF",Sat:"OFF"},
      vacations: [],
      depotWeights: Object.fromEntries(state.meta.depots.map(d=>[d,1]))
    };
    state.employees.push(e);
    refreshJsonArea();
    renderEmployees();
  });

  el.btnGenerate.addEventListener("click", ()=>{
    const y = selectedYear(), m = selectedMonth();
    if(!state.employees.length) return alert("Add employees first.");
    if(!confirm(`Generate schedule for ${ymKey(y,m)}?\n\nThis will overwrite shifts for that month (VAC is preserved).`)) return;

    // wipe month rows but keep VAC cells if already stored (we recompute VAC anyway)
    const ms = getMonthStore(y,m);
    for(const e of state.employees){
      ms[e.id] = {}; // reset
    }

    generateMonth(y,m);
    renderSchedule();
    refreshJsonArea();
    alert("Generated. Next: click ‚ÄúAssign Depots‚Äù to distribute by location fairly.");
  });

  el.btnAssignDepots.addEventListener("click", ()=>{
    const y = selectedYear(), m = selectedMonth();
    assignDepotsForMonth(y,m);
    renderSchedule();
    refreshJsonArea();
    alert("Depots assigned (fair rotation using depot weights).");
  });

  el.btnExport.addEventListener("click", exportCSV);

  el.btnLoad.addEventListener("click", ()=> {
    // sync settings before load
    state.apiUrl = el.apiUrl.value.trim();
    apiLoad();
  });
  el.btnSave.addEventListener("click", ()=> {
    state.apiUrl = el.apiUrl.value.trim();
    apiSave();
  });

  // settings inputs
  el.apiUrl.addEventListener("change", ()=>{
    state.apiUrl = el.apiUrl.value.trim();
    refreshJsonArea();
    setStatus(state.apiUrl ? "API configured" : "Offline", !!state.apiUrl);
  });

  el.depotsInput.addEventListener("change", ()=>{
    const depots = el.depotsInput.value.split(",").map(s=>s.trim()).filter(Boolean);
    if(!depots.length) return alert("At least 1 depot required.");
    state.meta.depots = depots;
    // ensure requirements exist
    state.meta.requirements = state.meta.requirements || {};
    for(const d of depots){
      if(!state.meta.requirements[d]) state.meta.requirements[d] = {M:0,A:0,N:0};
    }
    // remove requirements for deleted depots
    for(const d of Object.keys(state.meta.requirements)){
      if(!depots.includes(d)) delete state.meta.requirements[d];
    }
    // ensure employee depotWeights include new depots
    for(const e of state.employees){
      e.depotWeights = e.depotWeights || {};
      for(const d of depots){
        if(e.depotWeights[d]===undefined) e.depotWeights[d]=1;
      }
      for(const d of Object.keys(e.depotWeights)){
        if(!depots.includes(d)) delete e.depotWeights[d];
      }
    }
    renderRequirementsTable();
    renderEmployees();
    refreshJsonArea();
  });

  el.btnRefreshJson.addEventListener("click", refreshJsonArea);
  el.btnApplyJson.addEventListener("click", applyJsonFromArea);
  el.btnReset.addEventListener("click", ()=>{
    if(!confirm("Reset everything (employees, schedule, settings)?")) return;
    state.apiUrl = "";
    state.meta = { depots:["Budaiya","IsaTown"], requirements:{ Budaiya:{M:1,A:1,N:1}, IsaTown:{M:1,A:1,N:1} } };
    state.employees = [];
    state.schedule = {};
    render();
    alert("Reset complete.");
  });

  // ---- Escape helpers ----
  function escapeHtml(s){ return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }
  function escapeAttr(s){ return escapeHtml(s).replaceAll('"',"&quot;"); }

  // ---- Init ----
  initDateSelectors();
  render();
})();
</script>
</body>
</html>
